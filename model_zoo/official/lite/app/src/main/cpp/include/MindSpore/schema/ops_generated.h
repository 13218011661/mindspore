// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
#define FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace mindspore {
namespace schema {

struct Pad;

struct Maximum;

struct Minimum;

struct Flatten;

struct Concat;

struct SoftMax;

struct Activation;

struct ActivationGrad;

struct Conv2D;

struct Conv2DGradFilter;

struct Conv2DGradInput;

struct FusedBatchNorm;

struct CaffeBatchNorm;

struct BiasGrad;

struct SoftmaxCrossEntropy;

struct PoolingGrad;

struct Shape;

struct Nchw2Nhwc;

struct Nhwc2Nchw;

struct FakeQuantWithMinMaxVars;

struct BiasAdd;

struct Pooling;

struct DepthwiseConv2D;

struct DeDepthwiseConv2D;

struct Resize;

struct DetectionPostProcess;

struct FullConnection;

struct Mean;

struct DeConv2D;

struct BNGradInput;

struct Scale;

struct Eltwise;

struct Add;

struct Sub;

struct Mul;

struct Div;

struct AddGrad;

struct SubGrad;

struct MulGrad;

struct DivGrad;

struct RealDiv;

struct Rsqrt;

struct Equal;

struct Less;

struct Greater;

struct NotEqual;

struct LessEqual;

struct GreaterEqual;

struct Min;

struct Slice;

struct Floor;

struct Abs;

struct Neg;

struct Exp;

struct Cos;

struct Sin;

struct Sqrt;

struct Square;

struct Ceil;

struct Log;

struct Tan;

struct Atan;

struct Asin;

struct Reshape;

struct Power;

struct PowerGrad;

struct ArgMax;

struct ArgMin;

struct NetOutput;

struct MatMul;

struct CaffePReLU;

struct LeakyReLU;

struct StridedSlice;

struct Stack;

struct Range;

struct ExpandDims;

struct Tile;

struct Cast;

struct QuantDTypeCast;

struct Split;

struct Crop;

struct Permute;

struct Clip;

struct Constant;

struct Elu;

struct Broadcast;

struct BroadcastTo;

struct Lrn;

struct Reduce;

struct Prelu;

struct Transpose;

struct Squeeze;

struct Unsqueeze;

struct Upsample;

struct Dropout;

struct LocalResponseNormalization;

struct ZerosLike;

struct TopK;

struct SpaceToDepth;

struct SpaceToBatch;

struct SparseToDense;

struct ReverseSequence;

struct Rank;

struct Gather;

struct GatherNd;

struct Fill;

struct DepthToSpace;

struct BatchToSpace;

struct AddN;

struct EmbeddingLookup;

struct EmbeddingLookupSparse;

struct FloorDiv;

struct FloorMod;

struct L2Norm;

struct LogicalAnd;

struct LogicalOr;

struct LogicalXor;

struct LogicalNot;

struct MatrixDiag;

struct Select;

struct TfReduce;

struct Reverse;

struct Round;

struct Scatter;

struct ScatterND;

struct Unique;

struct Unstack;

struct OnnxInt8Quantize;

struct OnnxInt8Dequantize;

struct FakeQuantWithMinMax;

struct FakeQuantWithMinMaxPerChannel;

struct BatchNormFold;

struct MulFold;

struct AddFold;

struct SquaredDifference;

struct TupleGetItem;

struct OptMomentum;

struct Where;

struct OneHot;

struct Lstm;

struct PriorBox;

struct SpaceToBatchND;

struct TopKV2;

enum ResizeMethod {
  ResizeMethod_UNKNOW = -1,
  ResizeMethod_BILINEAR = 0,
  ResizeMethod_NEAREST_NEIGHBOR = 1,
  ResizeMethod_MIN = ResizeMethod_UNKNOW,
  ResizeMethod_MAX = ResizeMethod_NEAREST_NEIGHBOR
};

inline const ResizeMethod (&EnumValuesResizeMethod())[3] {
  static const ResizeMethod values[] = {
    ResizeMethod_UNKNOW,
    ResizeMethod_BILINEAR,
    ResizeMethod_NEAREST_NEIGHBOR
  };
  return values;
}

inline const char * const *EnumNamesResizeMethod() {
  static const char * const names[] = {
    "UNKNOW",
    "BILINEAR",
    "NEAREST_NEIGHBOR",
    nullptr
  };
  return names;
}

inline const char *EnumNameResizeMethod(ResizeMethod e) {
  if (e < ResizeMethod_UNKNOW || e > ResizeMethod_NEAREST_NEIGHBOR) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ResizeMethod_UNKNOW);
  return EnumNamesResizeMethod()[index];
}

enum Format {
  Format_NCHW = 0,
  Format_NHWC = 1,
  Format_NHWC4 = 2,
  Format_HWKC = 3,
  Format_HWCK = 4,
  Format_KCHW = 5,
  Format_CKHW = 6,
  Format_KHWC = 7,
  Format_CHWK = 8,
  Format_NC4HW4 = 100,
  Format_NUM_OF_FORMAT = 101,
  Format_MIN = Format_NCHW,
  Format_MAX = Format_NUM_OF_FORMAT
};

inline const Format (&EnumValuesFormat())[11] {
  static const Format values[] = {
    Format_NCHW,
    Format_NHWC,
    Format_NHWC4,
    Format_HWKC,
    Format_HWCK,
    Format_KCHW,
    Format_CKHW,
    Format_KHWC,
    Format_CHWK,
    Format_NC4HW4,
    Format_NUM_OF_FORMAT
  };
  return values;
}

inline const char *EnumNameFormat(Format e) {
  switch (e) {
    case Format_NCHW: return "NCHW";
    case Format_NHWC: return "NHWC";
    case Format_NHWC4: return "NHWC4";
    case Format_HWKC: return "HWKC";
    case Format_HWCK: return "HWCK";
    case Format_KCHW: return "KCHW";
    case Format_CKHW: return "CKHW";
    case Format_KHWC: return "KHWC";
    case Format_CHWK: return "CHWK";
    case Format_NC4HW4: return "NC4HW4";
    case Format_NUM_OF_FORMAT: return "NUM_OF_FORMAT";
    default: return "";
  }
}

enum ActivationType {
  ActivationType_NO_ACTIVATION = 0,
  ActivationType_RELU = 1,
  ActivationType_SIGMOID = 2,
  ActivationType_RELU6 = 3,
  ActivationType_ELU = 4,
  ActivationType_LEAKY_RELU = 5,
  ActivationType_ABS = 6,
  ActivationType_RELU1 = 7,
  ActivationType_SOFTSIGN = 8,
  ActivationType_SOFTPLUS = 9,
  ActivationType_TANH = 10,
  ActivationType_SELU = 11,
  ActivationType_HSWISH = 12,
  ActivationType_HSIGMOID = 13,
  ActivationType_THRESHOLDRELU = 14,
  ActivationType_LINEAR = 15,
  ActivationType_UNKNOW = 16,
  ActivationType_MIN = ActivationType_NO_ACTIVATION,
  ActivationType_MAX = ActivationType_UNKNOW
};

inline const ActivationType (&EnumValuesActivationType())[17] {
  static const ActivationType values[] = {
    ActivationType_NO_ACTIVATION,
    ActivationType_RELU,
    ActivationType_SIGMOID,
    ActivationType_RELU6,
    ActivationType_ELU,
    ActivationType_LEAKY_RELU,
    ActivationType_ABS,
    ActivationType_RELU1,
    ActivationType_SOFTSIGN,
    ActivationType_SOFTPLUS,
    ActivationType_TANH,
    ActivationType_SELU,
    ActivationType_HSWISH,
    ActivationType_HSIGMOID,
    ActivationType_THRESHOLDRELU,
    ActivationType_LINEAR,
    ActivationType_UNKNOW
  };
  return values;
}

inline const char * const *EnumNamesActivationType() {
  static const char * const names[] = {
    "NO_ACTIVATION",
    "RELU",
    "SIGMOID",
    "RELU6",
    "ELU",
    "LEAKY_RELU",
    "ABS",
    "RELU1",
    "SOFTSIGN",
    "SOFTPLUS",
    "TANH",
    "SELU",
    "HSWISH",
    "HSIGMOID",
    "THRESHOLDRELU",
    "LINEAR",
    "UNKNOW",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationType(ActivationType e) {
  if (e < ActivationType_NO_ACTIVATION || e > ActivationType_UNKNOW) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationType()[index];
}

enum ActivationGradType {
  ActivationGradType_NO_ACTIVATION = 0,
  ActivationGradType_RELU = 1,
  ActivationGradType_SIGMOID = 2,
  ActivationGradType_RELU6 = 3,
  ActivationGradType_ELU = 4,
  ActivationGradType_LEAKY_RELU = 5,
  ActivationGradType_ABS = 6,
  ActivationGradType_RELU1 = 7,
  ActivationGradType_SOFTSIGN = 8,
  ActivationGradType_SOFTPLUS = 9,
  ActivationGradType_TANH = 10,
  ActivationGradType_SELU = 11,
  ActivationGradType_HSWISH = 12,
  ActivationGradType_HSIGMOID = 13,
  ActivationGradType_THRESHOLDRELU = 14,
  ActivationGradType_LINEAR = 15,
  ActivationGradType_UNKNOW = 16,
  ActivationGradType_MIN = ActivationGradType_NO_ACTIVATION,
  ActivationGradType_MAX = ActivationGradType_UNKNOW
};

inline const ActivationGradType (&EnumValuesActivationGradType())[17] {
  static const ActivationGradType values[] = {
    ActivationGradType_NO_ACTIVATION,
    ActivationGradType_RELU,
    ActivationGradType_SIGMOID,
    ActivationGradType_RELU6,
    ActivationGradType_ELU,
    ActivationGradType_LEAKY_RELU,
    ActivationGradType_ABS,
    ActivationGradType_RELU1,
    ActivationGradType_SOFTSIGN,
    ActivationGradType_SOFTPLUS,
    ActivationGradType_TANH,
    ActivationGradType_SELU,
    ActivationGradType_HSWISH,
    ActivationGradType_HSIGMOID,
    ActivationGradType_THRESHOLDRELU,
    ActivationGradType_LINEAR,
    ActivationGradType_UNKNOW
  };
  return values;
}

inline const char * const *EnumNamesActivationGradType() {
  static const char * const names[] = {
    "NO_ACTIVATION",
    "RELU",
    "SIGMOID",
    "RELU6",
    "ELU",
    "LEAKY_RELU",
    "ABS",
    "RELU1",
    "SOFTSIGN",
    "SOFTPLUS",
    "TANH",
    "SELU",
    "HSWISH",
    "HSIGMOID",
    "THRESHOLDRELU",
    "LINEAR",
    "UNKNOW",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationGradType(ActivationGradType e) {
  if (e < ActivationGradType_NO_ACTIVATION || e > ActivationGradType_UNKNOW) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationGradType()[index];
}

enum ReduceType {
  ReduceType_REDUCE_MAX = 0,
  ReduceType_REDUCE_MEAN = 1,
  ReduceType_REDUCE_ALL = 2,
  ReduceType_REDUCE_ANY = 3,
  ReduceType_REDUCE_LOG_SUM_EXP = 4,
  ReduceType_REDUCE_PROD = 5,
  ReduceType_REDUCE_SUM = 6,
  ReduceType_UNKNOW = 7,
  ReduceType_MIN = ReduceType_REDUCE_MAX,
  ReduceType_MAX = ReduceType_UNKNOW
};

inline const ReduceType (&EnumValuesReduceType())[8] {
  static const ReduceType values[] = {
    ReduceType_REDUCE_MAX,
    ReduceType_REDUCE_MEAN,
    ReduceType_REDUCE_ALL,
    ReduceType_REDUCE_ANY,
    ReduceType_REDUCE_LOG_SUM_EXP,
    ReduceType_REDUCE_PROD,
    ReduceType_REDUCE_SUM,
    ReduceType_UNKNOW
  };
  return values;
}

inline const char * const *EnumNamesReduceType() {
  static const char * const names[] = {
    "REDUCE_MAX",
    "REDUCE_MEAN",
    "REDUCE_ALL",
    "REDUCE_ANY",
    "REDUCE_LOG_SUM_EXP",
    "REDUCE_PROD",
    "REDUCE_SUM",
    "UNKNOW",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceType(ReduceType e) {
  if (e < ReduceType_REDUCE_MAX || e > ReduceType_UNKNOW) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduceType()[index];
}

enum PoolMode {
  PoolMode_MAX_POOLING = 0,
  PoolMode_MEAN_POOLING = 1,
  PoolMode_MIN = PoolMode_MAX_POOLING,
  PoolMode_MAX = PoolMode_MEAN_POOLING
};

inline const PoolMode (&EnumValuesPoolMode())[2] {
  static const PoolMode values[] = {
    PoolMode_MAX_POOLING,
    PoolMode_MEAN_POOLING
  };
  return values;
}

inline const char * const *EnumNamesPoolMode() {
  static const char * const names[] = {
    "MAX_POOLING",
    "MEAN_POOLING",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolMode(PoolMode e) {
  if (e < PoolMode_MAX_POOLING || e > PoolMode_MEAN_POOLING) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoolMode()[index];
}

enum EltwiseMode {
  EltwiseMode_PROD = 0,
  EltwiseMode_SUM = 1,
  EltwiseMode_MAXIMUM = 2,
  EltwiseMode_UNKNOW = 3,
  EltwiseMode_MIN = EltwiseMode_PROD,
  EltwiseMode_MAX = EltwiseMode_UNKNOW
};

inline const EltwiseMode (&EnumValuesEltwiseMode())[4] {
  static const EltwiseMode values[] = {
    EltwiseMode_PROD,
    EltwiseMode_SUM,
    EltwiseMode_MAXIMUM,
    EltwiseMode_UNKNOW
  };
  return values;
}

inline const char * const *EnumNamesEltwiseMode() {
  static const char * const names[] = {
    "PROD",
    "SUM",
    "MAXIMUM",
    "UNKNOW",
    nullptr
  };
  return names;
}

inline const char *EnumNameEltwiseMode(EltwiseMode e) {
  if (e < EltwiseMode_PROD || e > EltwiseMode_UNKNOW) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEltwiseMode()[index];
}

enum PadMode {
  PadMode_NOTSET = 0,
  PadMode_SAME = 1,
  PadMode_VALID = 2,
  PadMode_CAFFE = 4,
  PadMode_MIN = PadMode_NOTSET,
  PadMode_MAX = PadMode_CAFFE
};

inline const PadMode (&EnumValuesPadMode())[4] {
  static const PadMode values[] = {
    PadMode_NOTSET,
    PadMode_SAME,
    PadMode_VALID,
    PadMode_CAFFE
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[] = {
    "NOTSET",
    "SAME",
    "VALID",
    "",
    "CAFFE",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (e < PadMode_NOTSET || e > PadMode_CAFFE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadMode()[index];
}

enum RoundMode {
  RoundMode_FLOOR = 0,
  RoundMode_CEIL = 1,
  RoundMode_MIN = RoundMode_FLOOR,
  RoundMode_MAX = RoundMode_CEIL
};

inline const RoundMode (&EnumValuesRoundMode())[2] {
  static const RoundMode values[] = {
    RoundMode_FLOOR,
    RoundMode_CEIL
  };
  return values;
}

inline const char * const *EnumNamesRoundMode() {
  static const char * const names[] = {
    "FLOOR",
    "CEIL",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoundMode(RoundMode e) {
  if (e < RoundMode_FLOOR || e > RoundMode_CEIL) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoundMode()[index];
}

enum PaddingMode {
  PaddingMode_CONSTANT = 0,
  PaddingMode_REFLECT = 1,
  PaddingMode_SYMMETRIC = 2,
  PaddingMode_MODE_RESERVED = 3,
  PaddingMode_MIN = PaddingMode_CONSTANT,
  PaddingMode_MAX = PaddingMode_MODE_RESERVED
};

inline const PaddingMode (&EnumValuesPaddingMode())[4] {
  static const PaddingMode values[] = {
    PaddingMode_CONSTANT,
    PaddingMode_REFLECT,
    PaddingMode_SYMMETRIC,
    PaddingMode_MODE_RESERVED
  };
  return values;
}

inline const char * const *EnumNamesPaddingMode() {
  static const char * const names[] = {
    "CONSTANT",
    "REFLECT",
    "SYMMETRIC",
    "MODE_RESERVED",
    nullptr
  };
  return names;
}

inline const char *EnumNamePaddingMode(PaddingMode e) {
  if (e < PaddingMode_CONSTANT || e > PaddingMode_MODE_RESERVED) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPaddingMode()[index];
}

enum ReduceMode {
  ReduceMode_ReduceMean = 0,
  ReduceMode_ReduceMax = 1,
  ReduceMode_ReduceMin = 2,
  ReduceMode_ReduceProd = 3,
  ReduceMode_ReduceSum = 4,
  ReduceMode_ReduceSumSquare = 5,
  ReduceMode_MIN = ReduceMode_ReduceMean,
  ReduceMode_MAX = ReduceMode_ReduceSumSquare
};

inline const ReduceMode (&EnumValuesReduceMode())[6] {
  static const ReduceMode values[] = {
    ReduceMode_ReduceMean,
    ReduceMode_ReduceMax,
    ReduceMode_ReduceMin,
    ReduceMode_ReduceProd,
    ReduceMode_ReduceSum,
    ReduceMode_ReduceSumSquare
  };
  return values;
}

inline const char * const *EnumNamesReduceMode() {
  static const char * const names[] = {
    "ReduceMean",
    "ReduceMax",
    "ReduceMin",
    "ReduceProd",
    "ReduceSum",
    "ReduceSumSquare",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceMode(ReduceMode e) {
  if (e < ReduceMode_ReduceMean || e > ReduceMode_ReduceSumSquare) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduceMode()[index];
}

struct Pad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDINGS = 4,
    VT_PADDINGMODE = 6,
    VT_CONSTANTVALUE = 8
  };
  const flatbuffers::Vector<int32_t> *paddings() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDINGS);
  }
  PaddingMode paddingMode() const {
    return static_cast<PaddingMode>(GetField<int8_t>(VT_PADDINGMODE, 0));
  }
  float constantValue() const {
    return GetField<float>(VT_CONSTANTVALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyVector(paddings()) &&
           VerifyField<int8_t>(verifier, VT_PADDINGMODE) &&
           VerifyField<float>(verifier, VT_CONSTANTVALUE) &&
           verifier.EndTable();
  }
};

struct PadBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_paddings(flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings) {
    fbb_.AddOffset(Pad::VT_PADDINGS, paddings);
  }
  void add_paddingMode(PaddingMode paddingMode) {
    fbb_.AddElement<int8_t>(Pad::VT_PADDINGMODE, static_cast<int8_t>(paddingMode), 0);
  }
  void add_constantValue(float constantValue) {
    fbb_.AddElement<float>(Pad::VT_CONSTANTVALUE, constantValue, 0.0f);
  }
  explicit PadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadBuilder &operator=(const PadBuilder &);
  flatbuffers::Offset<Pad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pad>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pad> CreatePad(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings = 0,
    PaddingMode paddingMode = PaddingMode_CONSTANT,
    float constantValue = 0.0f) {
  PadBuilder builder_(_fbb);
  builder_.add_constantValue(constantValue);
  builder_.add_paddings(paddings);
  builder_.add_paddingMode(paddingMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pad> CreatePadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *paddings = nullptr,
    PaddingMode paddingMode = PaddingMode_CONSTANT,
    float constantValue = 0.0f) {
  auto paddings__ = paddings ? _fbb.CreateVector<int32_t>(*paddings) : 0;
  return mindspore::schema::CreatePad(
      _fbb,
      paddings__,
      paddingMode,
      constantValue);
}

struct Maximum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MaximumBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaximumBuilder &operator=(const MaximumBuilder &);
  flatbuffers::Offset<Maximum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Maximum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Maximum> CreateMaximum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaximumBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Minimum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MinimumBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinimumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MinimumBuilder &operator=(const MinimumBuilder &);
  flatbuffers::Offset<Minimum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Minimum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Minimum> CreateMinimum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinimumBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Flatten FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FlattenBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FlattenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlattenBuilder &operator=(const FlattenBuilder &);
  flatbuffers::Offset<Flatten> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Flatten>(end);
    return o;
  }
};

inline flatbuffers::Offset<Flatten> CreateFlatten(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FlattenBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Concat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_N = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t n() const {
    return GetField<int32_t>(VT_N, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_N) &&
           verifier.EndTable();
  }
};

struct ConcatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Concat::VT_AXIS, axis, 0);
  }
  void add_n(int32_t n) {
    fbb_.AddElement<int32_t>(Concat::VT_N, n, 0);
  }
  explicit ConcatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatBuilder &operator=(const ConcatBuilder &);
  flatbuffers::Offset<Concat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Concat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Concat> CreateConcat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t n = 0) {
  ConcatBuilder builder_(_fbb);
  builder_.add_n(n);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct SoftMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct SoftMaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(SoftMax::VT_AXIS, axis, 0);
  }
  explicit SoftMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftMaxBuilder &operator=(const SoftMaxBuilder &);
  flatbuffers::Offset<SoftMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftMax> CreateSoftMax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  SoftMaxBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct Activation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  ActivationType type() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct ActivationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ActivationType type) {
    fbb_.AddElement<int8_t>(Activation::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit ActivationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActivationBuilder &operator=(const ActivationBuilder &);
  flatbuffers::Offset<Activation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Activation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Activation> CreateActivation(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationType type = ActivationType_NO_ACTIVATION) {
  ActivationBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct ActivationGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  ActivationGradType type() const {
    return static_cast<ActivationGradType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct ActivationGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ActivationGradType type) {
    fbb_.AddElement<int8_t>(ActivationGrad::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit ActivationGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActivationGradBuilder &operator=(const ActivationGradBuilder &);
  flatbuffers::Offset<ActivationGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActivationGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActivationGrad> CreateActivationGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationGradType type = ActivationGradType_NO_ACTIVATION) {
  ActivationGradBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Conv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_ACTIVATIONTYPE = 36
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct Conv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Conv2D::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Conv2D::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(Conv2D::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(Conv2D::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(Conv2D::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(Conv2D::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Conv2D::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Conv2D::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(Conv2D::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Conv2D::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Conv2D::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Conv2D::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Conv2D::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(Conv2D::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(Conv2D::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(Conv2D::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Conv2D::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit Conv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DBuilder &operator=(const Conv2DBuilder &);
  flatbuffers::Offset<Conv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2D> CreateConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  Conv2DBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

struct Conv2DGradFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_ACTIVATIONTYPE = 36
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct Conv2DGradFilterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(Conv2DGradFilter::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(Conv2DGradFilter::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Conv2DGradFilter::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit Conv2DGradFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DGradFilterBuilder &operator=(const Conv2DGradFilterBuilder &);
  flatbuffers::Offset<Conv2DGradFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DGradFilter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DGradFilter> CreateConv2DGradFilter(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  Conv2DGradFilterBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

struct Conv2DGradInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_ACTIVATIONTYPE = 36
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct Conv2DGradInputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(Conv2DGradInput::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(Conv2DGradInput::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Conv2DGradInput::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit Conv2DGradInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DGradInputBuilder &operator=(const Conv2DGradInputBuilder &);
  flatbuffers::Offset<Conv2DGradInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DGradInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DGradInput> CreateConv2DGradInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  Conv2DGradInputBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

struct FusedBatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4,
    VT_MOMENTUM = 6,
    VT_SPATIAL = 8
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.00001f);
  }
  float momentum() const {
    return GetField<float>(VT_MOMENTUM, 0.9f);
  }
  int32_t spatial() const {
    return GetField<int32_t>(VT_SPATIAL, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<float>(verifier, VT_MOMENTUM) &&
           VerifyField<int32_t>(verifier, VT_SPATIAL) &&
           verifier.EndTable();
  }
};

struct FusedBatchNormBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(FusedBatchNorm::VT_EPSILON, epsilon, 0.00001f);
  }
  void add_momentum(float momentum) {
    fbb_.AddElement<float>(FusedBatchNorm::VT_MOMENTUM, momentum, 0.9f);
  }
  void add_spatial(int32_t spatial) {
    fbb_.AddElement<int32_t>(FusedBatchNorm::VT_SPATIAL, spatial, 1);
  }
  explicit FusedBatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FusedBatchNormBuilder &operator=(const FusedBatchNormBuilder &);
  flatbuffers::Offset<FusedBatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FusedBatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.00001f,
    float momentum = 0.9f,
    int32_t spatial = 1) {
  FusedBatchNormBuilder builder_(_fbb);
  builder_.add_spatial(spatial);
  builder_.add_momentum(momentum);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

struct CaffeBatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           verifier.EndTable();
  }
};

struct CaffeBatchNormBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(CaffeBatchNorm::VT_EPSILON, epsilon, 0.0f);
  }
  explicit CaffeBatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CaffeBatchNormBuilder &operator=(const CaffeBatchNormBuilder &);
  flatbuffers::Offset<CaffeBatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CaffeBatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<CaffeBatchNorm> CreateCaffeBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.0f) {
  CaffeBatchNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

struct BiasGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct BiasGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(BiasGrad::VT_AXIS, axis);
  }
  explicit BiasGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BiasGradBuilder &operator=(const BiasGradBuilder &);
  flatbuffers::Offset<BiasGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BiasGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BiasGrad> CreateBiasGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  BiasGradBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<BiasGrad> CreateBiasGradDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateBiasGrad(
      _fbb,
      axis__);
}

struct SoftmaxCrossEntropy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct SoftmaxCrossEntropyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(SoftmaxCrossEntropy::VT_AXIS, axis);
  }
  explicit SoftmaxCrossEntropyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxCrossEntropyBuilder &operator=(const SoftmaxCrossEntropyBuilder &);
  flatbuffers::Offset<SoftmaxCrossEntropy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxCrossEntropy>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxCrossEntropy> CreateSoftmaxCrossEntropy(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  SoftmaxCrossEntropyBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<SoftmaxCrossEntropy> CreateSoftmaxCrossEntropyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateSoftmaxCrossEntropy(
      _fbb,
      axis__);
}

struct PoolingGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_POOLINGMODE = 6,
    VT_GLOBAL = 8,
    VT_WINDOWW = 10,
    VT_WINDOWH = 12,
    VT_STRIDEW = 14,
    VT_STRIDEH = 16,
    VT_PADMODE = 18,
    VT_PADUP = 20,
    VT_PADDOWN = 22,
    VT_PADLEFT = 24,
    VT_PADRIGHT = 26,
    VT_ROUNDMODE = 28
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  PoolMode poolingMode() const {
    return static_cast<PoolMode>(GetField<int8_t>(VT_POOLINGMODE, 0));
  }
  bool global() const {
    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
  }
  int32_t windowW() const {
    return GetField<int32_t>(VT_WINDOWW, 0);
  }
  int32_t windowH() const {
    return GetField<int32_t>(VT_WINDOWH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  RoundMode roundMode() const {
    return static_cast<RoundMode>(GetField<int8_t>(VT_ROUNDMODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_POOLINGMODE) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
           VerifyField<int32_t>(verifier, VT_WINDOWW) &&
           VerifyField<int32_t>(verifier, VT_WINDOWH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int8_t>(verifier, VT_ROUNDMODE) &&
           verifier.EndTable();
  }
};

struct PoolingGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_poolingMode(PoolMode poolingMode) {
    fbb_.AddElement<int8_t>(PoolingGrad::VT_POOLINGMODE, static_cast<int8_t>(poolingMode), 0);
  }
  void add_global(bool global) {
    fbb_.AddElement<uint8_t>(PoolingGrad::VT_GLOBAL, static_cast<uint8_t>(global), 0);
  }
  void add_windowW(int32_t windowW) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_WINDOWW, windowW, 0);
  }
  void add_windowH(int32_t windowH) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_WINDOWH, windowH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(PoolingGrad::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_PADRIGHT, padRight, 0);
  }
  void add_roundMode(RoundMode roundMode) {
    fbb_.AddElement<int8_t>(PoolingGrad::VT_ROUNDMODE, static_cast<int8_t>(roundMode), 0);
  }
  explicit PoolingGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoolingGradBuilder &operator=(const PoolingGradBuilder &);
  flatbuffers::Offset<PoolingGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PoolingGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<PoolingGrad> CreatePoolingGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    PoolMode poolingMode = PoolMode_MAX_POOLING,
    bool global = false,
    int32_t windowW = 0,
    int32_t windowH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    RoundMode roundMode = RoundMode_FLOOR) {
  PoolingGradBuilder builder_(_fbb);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_windowH(windowH);
  builder_.add_windowW(windowW);
  builder_.add_format(format);
  builder_.add_roundMode(roundMode);
  builder_.add_padMode(padMode);
  builder_.add_global(global);
  builder_.add_poolingMode(poolingMode);
  return builder_.Finish();
}

struct Shape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ShapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShapeBuilder &operator=(const ShapeBuilder &);
  flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shape> CreateShape(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ShapeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Nchw2Nhwc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct Nchw2NhwcBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Nchw2NhwcBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Nchw2NhwcBuilder &operator=(const Nchw2NhwcBuilder &);
  flatbuffers::Offset<Nchw2Nhwc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Nchw2Nhwc>(end);
    return o;
  }
};

inline flatbuffers::Offset<Nchw2Nhwc> CreateNchw2Nhwc(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Nchw2NhwcBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Nhwc2Nchw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct Nhwc2NchwBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Nhwc2NchwBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Nhwc2NchwBuilder &operator=(const Nhwc2NchwBuilder &);
  flatbuffers::Offset<Nhwc2Nchw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Nhwc2Nchw>(end);
    return o;
  }
};

inline flatbuffers::Offset<Nhwc2Nchw> CreateNhwc2Nchw(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Nhwc2NchwBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FakeQuantWithMinMaxVars FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NARROWRANGE = 4,
    VT_NUMBITS = 6
  };
  bool narrowRange() const {
    return GetField<uint8_t>(VT_NARROWRANGE, 0) != 0;
  }
  int32_t numBits() const {
    return GetField<int32_t>(VT_NUMBITS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NARROWRANGE) &&
           VerifyField<int32_t>(verifier, VT_NUMBITS) &&
           verifier.EndTable();
  }
};

struct FakeQuantWithMinMaxVarsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_narrowRange(bool narrowRange) {
    fbb_.AddElement<uint8_t>(FakeQuantWithMinMaxVars::VT_NARROWRANGE, static_cast<uint8_t>(narrowRange), 0);
  }
  void add_numBits(int32_t numBits) {
    fbb_.AddElement<int32_t>(FakeQuantWithMinMaxVars::VT_NUMBITS, numBits, 0);
  }
  explicit FakeQuantWithMinMaxVarsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantWithMinMaxVarsBuilder &operator=(const FakeQuantWithMinMaxVarsBuilder &);
  flatbuffers::Offset<FakeQuantWithMinMaxVars> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMaxVars>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool narrowRange = false,
    int32_t numBits = 0) {
  FakeQuantWithMinMaxVarsBuilder builder_(_fbb);
  builder_.add_numBits(numBits);
  builder_.add_narrowRange(narrowRange);
  return builder_.Finish();
}

struct BiasAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct BiasAddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(BiasAdd::VT_AXIS, axis);
  }
  explicit BiasAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BiasAddBuilder &operator=(const BiasAddBuilder &);
  flatbuffers::Offset<BiasAdd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BiasAdd>(end);
    return o;
  }
};

inline flatbuffers::Offset<BiasAdd> CreateBiasAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  BiasAddBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<BiasAdd> CreateBiasAddDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateBiasAdd(
      _fbb,
      axis__);
}

struct Pooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_POOLINGMODE = 6,
    VT_GLOBAL = 8,
    VT_WINDOWW = 10,
    VT_WINDOWH = 12,
    VT_STRIDEW = 14,
    VT_STRIDEH = 16,
    VT_PADMODE = 18,
    VT_PADUP = 20,
    VT_PADDOWN = 22,
    VT_PADLEFT = 24,
    VT_PADRIGHT = 26,
    VT_ROUNDMODE = 28
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  PoolMode poolingMode() const {
    return static_cast<PoolMode>(GetField<int8_t>(VT_POOLINGMODE, 0));
  }
  bool global() const {
    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
  }
  int32_t windowW() const {
    return GetField<int32_t>(VT_WINDOWW, 0);
  }
  int32_t windowH() const {
    return GetField<int32_t>(VT_WINDOWH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  RoundMode roundMode() const {
    return static_cast<RoundMode>(GetField<int8_t>(VT_ROUNDMODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_POOLINGMODE) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
           VerifyField<int32_t>(verifier, VT_WINDOWW) &&
           VerifyField<int32_t>(verifier, VT_WINDOWH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int8_t>(verifier, VT_ROUNDMODE) &&
           verifier.EndTable();
  }
};

struct PoolingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Pooling::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_poolingMode(PoolMode poolingMode) {
    fbb_.AddElement<int8_t>(Pooling::VT_POOLINGMODE, static_cast<int8_t>(poolingMode), 0);
  }
  void add_global(bool global) {
    fbb_.AddElement<uint8_t>(Pooling::VT_GLOBAL, static_cast<uint8_t>(global), 0);
  }
  void add_windowW(int32_t windowW) {
    fbb_.AddElement<int32_t>(Pooling::VT_WINDOWW, windowW, 0);
  }
  void add_windowH(int32_t windowH) {
    fbb_.AddElement<int32_t>(Pooling::VT_WINDOWH, windowH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Pooling::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Pooling::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(Pooling::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADRIGHT, padRight, 0);
  }
  void add_roundMode(RoundMode roundMode) {
    fbb_.AddElement<int8_t>(Pooling::VT_ROUNDMODE, static_cast<int8_t>(roundMode), 0);
  }
  explicit PoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoolingBuilder &operator=(const PoolingBuilder &);
  flatbuffers::Offset<Pooling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pooling>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pooling> CreatePooling(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    PoolMode poolingMode = PoolMode_MAX_POOLING,
    bool global = false,
    int32_t windowW = 0,
    int32_t windowH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    RoundMode roundMode = RoundMode_FLOOR) {
  PoolingBuilder builder_(_fbb);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_windowH(windowH);
  builder_.add_windowW(windowW);
  builder_.add_format(format);
  builder_.add_roundMode(roundMode);
  builder_.add_padMode(padMode);
  builder_.add_global(global);
  builder_.add_poolingMode(poolingMode);
  return builder_.Finish();
}

struct DepthwiseConv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_CHANNELIN = 6,
    VT_CHANNELMULTIPLIER = 8,
    VT_KERNELW = 10,
    VT_KERNELH = 12,
    VT_STRIDEW = 14,
    VT_STRIDEH = 16,
    VT_PADMODE = 18,
    VT_PADUP = 20,
    VT_PADDOWN = 22,
    VT_PADLEFT = 24,
    VT_PADRIGHT = 26,
    VT_DILATEW = 28,
    VT_DILATEH = 30,
    VT_HASBIAS = 32,
    VT_ACTIVATIONTYPE = 34
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelMultiplier() const {
    return GetField<int32_t>(VT_CHANNELMULTIPLIER, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELMULTIPLIER) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct DepthwiseConv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelMultiplier(int32_t channelMultiplier) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_CHANNELMULTIPLIER, channelMultiplier, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(DepthwiseConv2D::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(DepthwiseConv2D::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(DepthwiseConv2D::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DepthwiseConv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthwiseConv2DBuilder &operator=(const DepthwiseConv2DBuilder &);
  flatbuffers::Offset<DepthwiseConv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthwiseConv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthwiseConv2D> CreateDepthwiseConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t channelIn = 0,
    int32_t channelMultiplier = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  DepthwiseConv2DBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelMultiplier(channelMultiplier);
  builder_.add_channelIn(channelIn);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

struct DeDepthwiseConv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_CHANNELIN = 6,
    VT_CHANNELMULTIPLIER = 8,
    VT_KERNELW = 10,
    VT_KERNELH = 12,
    VT_STRIDEW = 14,
    VT_STRIDEH = 16,
    VT_PADMODE = 18,
    VT_PADUP = 20,
    VT_PADDOWN = 22,
    VT_PADLEFT = 24,
    VT_PADRIGHT = 26,
    VT_DILATEW = 28,
    VT_DILATEH = 30,
    VT_HASBIAS = 32,
    VT_ACTIVATIONTYPE = 34
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelMultiplier() const {
    return GetField<int32_t>(VT_CHANNELMULTIPLIER, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELMULTIPLIER) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct DeDepthwiseConv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelMultiplier(int32_t channelMultiplier) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_CHANNELMULTIPLIER, channelMultiplier, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(DeDepthwiseConv2D::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(DeDepthwiseConv2D::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(DeDepthwiseConv2D::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DeDepthwiseConv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeDepthwiseConv2DBuilder &operator=(const DeDepthwiseConv2DBuilder &);
  flatbuffers::Offset<DeDepthwiseConv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeDepthwiseConv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeDepthwiseConv2D> CreateDeDepthwiseConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t channelIn = 0,
    int32_t channelMultiplier = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  DeDepthwiseConv2DBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelMultiplier(channelMultiplier);
  builder_.add_channelIn(channelIn);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

struct Resize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_METHOD = 6,
    VT_NEWHEIGHT = 8,
    VT_NEWWIDTH = 10,
    VT_ALIGNCORNERS = 12,
    VT_PRESERVEASPECTRATIO = 14
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  ResizeMethod method() const {
    return static_cast<ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
  }
  int64_t newHeight() const {
    return GetField<int64_t>(VT_NEWHEIGHT, 0);
  }
  int64_t newWidth() const {
    return GetField<int64_t>(VT_NEWWIDTH, 0);
  }
  bool alignCorners() const {
    return GetField<uint8_t>(VT_ALIGNCORNERS, 0) != 0;
  }
  bool preserveAspectRatio() const {
    return GetField<uint8_t>(VT_PRESERVEASPECTRATIO, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_METHOD) &&
           VerifyField<int64_t>(verifier, VT_NEWHEIGHT) &&
           VerifyField<int64_t>(verifier, VT_NEWWIDTH) &&
           VerifyField<uint8_t>(verifier, VT_ALIGNCORNERS) &&
           VerifyField<uint8_t>(verifier, VT_PRESERVEASPECTRATIO) &&
           verifier.EndTable();
  }
};

struct ResizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Resize::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_method(ResizeMethod method) {
    fbb_.AddElement<int8_t>(Resize::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_newHeight(int64_t newHeight) {
    fbb_.AddElement<int64_t>(Resize::VT_NEWHEIGHT, newHeight, 0);
  }
  void add_newWidth(int64_t newWidth) {
    fbb_.AddElement<int64_t>(Resize::VT_NEWWIDTH, newWidth, 0);
  }
  void add_alignCorners(bool alignCorners) {
    fbb_.AddElement<uint8_t>(Resize::VT_ALIGNCORNERS, static_cast<uint8_t>(alignCorners), 0);
  }
  void add_preserveAspectRatio(bool preserveAspectRatio) {
    fbb_.AddElement<uint8_t>(Resize::VT_PRESERVEASPECTRATIO, static_cast<uint8_t>(preserveAspectRatio), 0);
  }
  explicit ResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeBuilder &operator=(const ResizeBuilder &);
  flatbuffers::Offset<Resize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resize> CreateResize(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    ResizeMethod method = ResizeMethod_BILINEAR,
    int64_t newHeight = 0,
    int64_t newWidth = 0,
    bool alignCorners = false,
    bool preserveAspectRatio = false) {
  ResizeBuilder builder_(_fbb);
  builder_.add_newWidth(newWidth);
  builder_.add_newHeight(newHeight);
  builder_.add_format(format);
  builder_.add_preserveAspectRatio(preserveAspectRatio);
  builder_.add_alignCorners(alignCorners);
  builder_.add_method(method);
  return builder_.Finish();
}

struct DetectionPostProcess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_INPUTSIZE = 6,
    VT_HSCALE = 8,
    VT_WSCALE = 10,
    VT_XSCALE = 12,
    VT_YSCALE = 14,
    VT_NMSIOUTHRESHOLD = 16,
    VT_NMSSCORETHRESHOLD = 18,
    VT_MAXDETECTIONS = 20,
    VT_DETECTIONSPRECLASS = 22,
    VT_MAXCLASSESPREDETECTION = 24,
    VT_NUMCLASSES = 26,
    VT_USEREGULARNMS = 28
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t inputSize() const {
    return GetField<int32_t>(VT_INPUTSIZE, 0);
  }
  float hScale() const {
    return GetField<float>(VT_HSCALE, 0.0f);
  }
  float wScale() const {
    return GetField<float>(VT_WSCALE, 0.0f);
  }
  float xScale() const {
    return GetField<float>(VT_XSCALE, 0.0f);
  }
  float yScale() const {
    return GetField<float>(VT_YSCALE, 0.0f);
  }
  float NmsIouThreshold() const {
    return GetField<float>(VT_NMSIOUTHRESHOLD, 0.0f);
  }
  float NmsScoreThreshold() const {
    return GetField<float>(VT_NMSSCORETHRESHOLD, 0.0f);
  }
  int64_t MaxDetections() const {
    return GetField<int64_t>(VT_MAXDETECTIONS, 0);
  }
  int64_t DetectionsPreClass() const {
    return GetField<int64_t>(VT_DETECTIONSPRECLASS, 0);
  }
  int64_t MaxClassesPreDetection() const {
    return GetField<int64_t>(VT_MAXCLASSESPREDETECTION, 0);
  }
  int64_t NumClasses() const {
    return GetField<int64_t>(VT_NUMCLASSES, 0);
  }
  bool UseRegularNms() const {
    return GetField<uint8_t>(VT_USEREGULARNMS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_INPUTSIZE) &&
           VerifyField<float>(verifier, VT_HSCALE) &&
           VerifyField<float>(verifier, VT_WSCALE) &&
           VerifyField<float>(verifier, VT_XSCALE) &&
           VerifyField<float>(verifier, VT_YSCALE) &&
           VerifyField<float>(verifier, VT_NMSIOUTHRESHOLD) &&
           VerifyField<float>(verifier, VT_NMSSCORETHRESHOLD) &&
           VerifyField<int64_t>(verifier, VT_MAXDETECTIONS) &&
           VerifyField<int64_t>(verifier, VT_DETECTIONSPRECLASS) &&
           VerifyField<int64_t>(verifier, VT_MAXCLASSESPREDETECTION) &&
           VerifyField<int64_t>(verifier, VT_NUMCLASSES) &&
           VerifyField<uint8_t>(verifier, VT_USEREGULARNMS) &&
           verifier.EndTable();
  }
};

struct DetectionPostProcessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(DetectionPostProcess::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_inputSize(int32_t inputSize) {
    fbb_.AddElement<int32_t>(DetectionPostProcess::VT_INPUTSIZE, inputSize, 0);
  }
  void add_hScale(float hScale) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_HSCALE, hScale, 0.0f);
  }
  void add_wScale(float wScale) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_WSCALE, wScale, 0.0f);
  }
  void add_xScale(float xScale) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_XSCALE, xScale, 0.0f);
  }
  void add_yScale(float yScale) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_YSCALE, yScale, 0.0f);
  }
  void add_NmsIouThreshold(float NmsIouThreshold) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_NMSIOUTHRESHOLD, NmsIouThreshold, 0.0f);
  }
  void add_NmsScoreThreshold(float NmsScoreThreshold) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_NMSSCORETHRESHOLD, NmsScoreThreshold, 0.0f);
  }
  void add_MaxDetections(int64_t MaxDetections) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAXDETECTIONS, MaxDetections, 0);
  }
  void add_DetectionsPreClass(int64_t DetectionsPreClass) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_DETECTIONSPRECLASS, DetectionsPreClass, 0);
  }
  void add_MaxClassesPreDetection(int64_t MaxClassesPreDetection) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAXCLASSESPREDETECTION, MaxClassesPreDetection, 0);
  }
  void add_NumClasses(int64_t NumClasses) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_NUMCLASSES, NumClasses, 0);
  }
  void add_UseRegularNms(bool UseRegularNms) {
    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_USEREGULARNMS, static_cast<uint8_t>(UseRegularNms), 0);
  }
  explicit DetectionPostProcessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DetectionPostProcessBuilder &operator=(const DetectionPostProcessBuilder &);
  flatbuffers::Offset<DetectionPostProcess> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectionPostProcess>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t inputSize = 0,
    float hScale = 0.0f,
    float wScale = 0.0f,
    float xScale = 0.0f,
    float yScale = 0.0f,
    float NmsIouThreshold = 0.0f,
    float NmsScoreThreshold = 0.0f,
    int64_t MaxDetections = 0,
    int64_t DetectionsPreClass = 0,
    int64_t MaxClassesPreDetection = 0,
    int64_t NumClasses = 0,
    bool UseRegularNms = false) {
  DetectionPostProcessBuilder builder_(_fbb);
  builder_.add_NumClasses(NumClasses);
  builder_.add_MaxClassesPreDetection(MaxClassesPreDetection);
  builder_.add_DetectionsPreClass(DetectionsPreClass);
  builder_.add_MaxDetections(MaxDetections);
  builder_.add_NmsScoreThreshold(NmsScoreThreshold);
  builder_.add_NmsIouThreshold(NmsIouThreshold);
  builder_.add_yScale(yScale);
  builder_.add_xScale(xScale);
  builder_.add_wScale(wScale);
  builder_.add_hScale(hScale);
  builder_.add_inputSize(inputSize);
  builder_.add_format(format);
  builder_.add_UseRegularNms(UseRegularNms);
  return builder_.Finish();
}

struct FullConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASBIAS = 4,
    VT_AXIS = 6
  };
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct FullConnectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(FullConnection::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(FullConnection::VT_AXIS, axis, 0);
  }
  explicit FullConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FullConnectionBuilder &operator=(const FullConnectionBuilder &);
  flatbuffers::Offset<FullConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullConnection>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullConnection> CreateFullConnection(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool hasBias = false,
    int32_t axis = 0) {
  FullConnectionBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_hasBias(hasBias);
  return builder_.Finish();
}

struct Mean FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_KEEPDIMS = 6
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS) &&
           verifier.EndTable();
  }
};

struct MeanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(Mean::VT_AXIS, axis);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(Mean::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  explicit MeanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeanBuilder &operator=(const MeanBuilder &);
  flatbuffers::Offset<Mean> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mean>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mean> CreateMean(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0,
    bool keepDims = false) {
  MeanBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_keepDims(keepDims);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mean> CreateMeanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr,
    bool keepDims = false) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateMean(
      _fbb,
      axis__,
      keepDims);
}

struct DeConv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_ACTIVATIONTYPE = 36
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct DeConv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(DeConv2D::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(DeConv2D::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(DeConv2D::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DeConv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeConv2DBuilder &operator=(const DeConv2DBuilder &);
  flatbuffers::Offset<DeConv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeConv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeConv2D> CreateDeConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  DeConv2DBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

struct BNGradInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPS = 4,
    VT_CHANNELS = 6
  };
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  int32_t channels() const {
    return GetField<int32_t>(VT_CHANNELS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPS) &&
           VerifyField<int32_t>(verifier, VT_CHANNELS) &&
           verifier.EndTable();
  }
};

struct BNGradInputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eps(float eps) {
    fbb_.AddElement<float>(BNGradInput::VT_EPS, eps, 0.0f);
  }
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(BNGradInput::VT_CHANNELS, channels, 0);
  }
  explicit BNGradInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BNGradInputBuilder &operator=(const BNGradInputBuilder &);
  flatbuffers::Offset<BNGradInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BNGradInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<BNGradInput> CreateBNGradInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    float eps = 0.0f,
    int32_t channels = 0) {
  BNGradInputBuilder builder_(_fbb);
  builder_.add_channels(channels);
  builder_.add_eps(eps);
  return builder_.Finish();
}

struct Scale FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
};

struct ScaleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Scale::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit ScaleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScaleBuilder &operator=(const ScaleBuilder &);
  flatbuffers::Offset<Scale> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scale>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scale> CreateScale(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW) {
  ScaleBuilder builder_(_fbb);
  builder_.add_format(format);
  return builder_.Finish();
}

struct Eltwise FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  EltwiseMode mode() const {
    return static_cast<EltwiseMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
};

struct EltwiseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(EltwiseMode mode) {
    fbb_.AddElement<int8_t>(Eltwise::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit EltwiseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EltwiseBuilder &operator=(const EltwiseBuilder &);
  flatbuffers::Offset<Eltwise> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Eltwise>(end);
    return o;
  }
};

inline flatbuffers::Offset<Eltwise> CreateEltwise(
    flatbuffers::FlatBufferBuilder &_fbb,
    EltwiseMode mode = EltwiseMode_PROD) {
  EltwiseBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBuilder &operator=(const AddBuilder &);
  flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Add>(end);
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Sub FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SubBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SubBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubBuilder &operator=(const SubBuilder &);
  flatbuffers::Offset<Sub> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sub>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sub> CreateSub(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SubBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Mul FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MulBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MulBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulBuilder &operator=(const MulBuilder &);
  flatbuffers::Offset<Mul> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mul>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mul> CreateMul(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MulBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Div FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DivBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DivBuilder &operator=(const DivBuilder &);
  flatbuffers::Offset<Div> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Div>(end);
    return o;
  }
};

inline flatbuffers::Offset<Div> CreateDiv(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DivBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AddGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AddGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddGradBuilder &operator=(const AddGradBuilder &);
  flatbuffers::Offset<AddGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddGrad> CreateAddGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SubGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SubGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SubGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubGradBuilder &operator=(const SubGradBuilder &);
  flatbuffers::Offset<SubGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGrad> CreateSubGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SubGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MulGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MulGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MulGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulGradBuilder &operator=(const MulGradBuilder &);
  flatbuffers::Offset<MulGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulGrad> CreateMulGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MulGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DivGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DivGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DivGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DivGradBuilder &operator=(const DivGradBuilder &);
  flatbuffers::Offset<DivGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivGrad> CreateDivGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DivGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RealDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RealDivBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RealDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RealDivBuilder &operator=(const RealDivBuilder &);
  flatbuffers::Offset<RealDiv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RealDiv>(end);
    return o;
  }
};

inline flatbuffers::Offset<RealDiv> CreateRealDiv(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RealDivBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Rsqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RsqrtBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RsqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RsqrtBuilder &operator=(const RsqrtBuilder &);
  flatbuffers::Offset<Rsqrt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rsqrt>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rsqrt> CreateRsqrt(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RsqrtBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Equal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EqualBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EqualBuilder &operator=(const EqualBuilder &);
  flatbuffers::Offset<Equal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Equal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Equal> CreateEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EqualBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Less FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessBuilder &operator=(const LessBuilder &);
  flatbuffers::Offset<Less> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Less>(end);
    return o;
  }
};

inline flatbuffers::Offset<Less> CreateLess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Greater FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GreaterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterBuilder &operator=(const GreaterBuilder &);
  flatbuffers::Offset<Greater> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Greater>(end);
    return o;
  }
};

inline flatbuffers::Offset<Greater> CreateGreater(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NotEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NotEqualBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotEqualBuilder &operator=(const NotEqualBuilder &);
  flatbuffers::Offset<NotEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqual> CreateNotEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LessEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LessEqualBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessEqualBuilder &operator=(const LessEqualBuilder &);
  flatbuffers::Offset<LessEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqual> CreateLessEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GreaterEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GreaterEqualBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterEqualBuilder &operator=(const GreaterEqualBuilder &);
  flatbuffers::Offset<GreaterEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Min FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MinBuilder &operator=(const MinBuilder &);
  flatbuffers::Offset<Min> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Min>(end);
    return o;
  }
};

inline flatbuffers::Offset<Min> CreateMin(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Slice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_BEGIN = 6,
    VT_SIZE = 8
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  const flatbuffers::Vector<int32_t> *begin() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BEGIN);
  }
  const flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_BEGIN) &&
           verifier.VerifyVector(begin()) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.VerifyVector(size()) &&
           verifier.EndTable();
  }
};

struct SliceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Slice::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_begin(flatbuffers::Offset<flatbuffers::Vector<int32_t>> begin) {
    fbb_.AddOffset(Slice::VT_BEGIN, begin);
  }
  void add_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(Slice::VT_SIZE, size);
  }
  explicit SliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceBuilder &operator=(const SliceBuilder &);
  flatbuffers::Offset<Slice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Slice>(end);
    return o;
  }
};

inline flatbuffers::Offset<Slice> CreateSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> begin = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> size = 0) {
  SliceBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_begin(begin);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<Slice> CreateSliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    const std::vector<int32_t> *begin = nullptr,
    const std::vector<int32_t> *size = nullptr) {
  auto begin__ = begin ? _fbb.CreateVector<int32_t>(*begin) : 0;
  auto size__ = size ? _fbb.CreateVector<int32_t>(*size) : 0;
  return mindspore::schema::CreateSlice(
      _fbb,
      format,
      begin__,
      size__);
}

struct Floor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorBuilder &operator=(const FloorBuilder &);
  flatbuffers::Offset<Floor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Floor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Floor> CreateFloor(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Abs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AbsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AbsBuilder &operator=(const AbsBuilder &);
  flatbuffers::Offset<Abs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Abs>(end);
    return o;
  }
};

inline flatbuffers::Offset<Abs> CreateAbs(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Neg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NegBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NegBuilder &operator=(const NegBuilder &);
  flatbuffers::Offset<Neg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Neg>(end);
    return o;
  }
};

inline flatbuffers::Offset<Neg> CreateNeg(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Exp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ExpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpBuilder &operator=(const ExpBuilder &);
  flatbuffers::Offset<Exp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exp> CreateExp(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Cos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CosBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CosBuilder &operator=(const CosBuilder &);
  flatbuffers::Offset<Cos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cos>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cos> CreateCos(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CosBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Sin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SinBuilder &operator=(const SinBuilder &);
  flatbuffers::Offset<Sin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sin>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sin> CreateSin(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SinBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Sqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SqrtBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqrtBuilder &operator=(const SqrtBuilder &);
  flatbuffers::Offset<Sqrt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sqrt>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sqrt> CreateSqrt(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SqrtBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Square FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SquareBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquareBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquareBuilder &operator=(const SquareBuilder &);
  flatbuffers::Offset<Square> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Square>(end);
    return o;
  }
};

inline flatbuffers::Offset<Square> CreateSquare(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquareBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Ceil FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CeilBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CeilBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CeilBuilder &operator=(const CeilBuilder &);
  flatbuffers::Offset<Ceil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ceil>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ceil> CreateCeil(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CeilBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Log FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogBuilder &operator=(const LogBuilder &);
  flatbuffers::Offset<Log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Log>(end);
    return o;
  }
};

inline flatbuffers::Offset<Log> CreateLog(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Tan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TanBuilder &operator=(const TanBuilder &);
  flatbuffers::Offset<Tan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tan>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tan> CreateTan(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TanBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Atan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AtanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AtanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AtanBuilder &operator=(const AtanBuilder &);
  flatbuffers::Offset<Atan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Atan>(end);
    return o;
  }
};

inline flatbuffers::Offset<Atan> CreateAtan(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AtanBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Asin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AsinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AsinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AsinBuilder &operator=(const AsinBuilder &);
  flatbuffers::Offset<Asin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Asin>(end);
    return o;
  }
};

inline flatbuffers::Offset<Asin> CreateAsin(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AsinBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Reshape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_SHAPE = 6
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  const flatbuffers::Vector<int64_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           verifier.EndTable();
  }
};

struct ReshapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Reshape::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape) {
    fbb_.AddOffset(Reshape::VT_SHAPE, shape);
  }
  explicit ReshapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReshapeBuilder &operator=(const ReshapeBuilder &);
  flatbuffers::Offset<Reshape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reshape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reshape> CreateReshape(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape = 0) {
  ReshapeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reshape> CreateReshapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    const std::vector<int64_t> *shape = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int64_t>(*shape) : 0;
  return mindspore::schema::CreateReshape(
      _fbb,
      format,
      shape__);
}

struct Power FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POWER = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float power() const {
    return GetField<float>(VT_POWER, 0.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_POWER) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
};

struct PowerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_power(float power) {
    fbb_.AddElement<float>(Power::VT_POWER, power, 0.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(Power::VT_SCALE, scale, 0.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(Power::VT_SHIFT, shift, 0.0f);
  }
  explicit PowerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PowerBuilder &operator=(const PowerBuilder &);
  flatbuffers::Offset<Power> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Power>(end);
    return o;
  }
};

inline flatbuffers::Offset<Power> CreatePower(
    flatbuffers::FlatBufferBuilder &_fbb,
    float power = 0.0f,
    float scale = 0.0f,
    float shift = 0.0f) {
  PowerBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_power(power);
  return builder_.Finish();
}

struct PowerGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POWER = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float power() const {
    return GetField<float>(VT_POWER, 0.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_POWER) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
};

struct PowerGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_power(float power) {
    fbb_.AddElement<float>(PowerGrad::VT_POWER, power, 0.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(PowerGrad::VT_SCALE, scale, 0.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(PowerGrad::VT_SHIFT, shift, 0.0f);
  }
  explicit PowerGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PowerGradBuilder &operator=(const PowerGradBuilder &);
  flatbuffers::Offset<PowerGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowerGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowerGrad> CreatePowerGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float power = 0.0f,
    float scale = 0.0f,
    float shift = 0.0f) {
  PowerGradBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_power(power);
  return builder_.Finish();
}

struct ArgMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OUTMAXVALUE = 6,
    VT_TOPK = 8,
    VT_KEEPDIMS = 10,
    VT_AXISTYPE = 12
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool outMaxValue() const {
    return GetField<uint8_t>(VT_OUTMAXVALUE, 0) != 0;
  }
  int32_t topK() const {
    return GetField<int32_t>(VT_TOPK, 1);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  int32_t axisType() const {
    return GetField<int32_t>(VT_AXISTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<uint8_t>(verifier, VT_OUTMAXVALUE) &&
           VerifyField<int32_t>(verifier, VT_TOPK) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS) &&
           VerifyField<int32_t>(verifier, VT_AXISTYPE) &&
           verifier.EndTable();
  }
};

struct ArgMaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMax::VT_AXIS, axis, 0);
  }
  void add_outMaxValue(bool outMaxValue) {
    fbb_.AddElement<uint8_t>(ArgMax::VT_OUTMAXVALUE, static_cast<uint8_t>(outMaxValue), 0);
  }
  void add_topK(int32_t topK) {
    fbb_.AddElement<int32_t>(ArgMax::VT_TOPK, topK, 1);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(ArgMax::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  void add_axisType(int32_t axisType) {
    fbb_.AddElement<int32_t>(ArgMax::VT_AXISTYPE, axisType, 0);
  }
  explicit ArgMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMaxBuilder &operator=(const ArgMaxBuilder &);
  flatbuffers::Offset<ArgMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMax> CreateArgMax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    bool outMaxValue = false,
    int32_t topK = 1,
    bool keepDims = false,
    int32_t axisType = 0) {
  ArgMaxBuilder builder_(_fbb);
  builder_.add_axisType(axisType);
  builder_.add_topK(topK);
  builder_.add_axis(axis);
  builder_.add_keepDims(keepDims);
  builder_.add_outMaxValue(outMaxValue);
  return builder_.Finish();
}

struct ArgMin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OUTMAXVALUE = 6,
    VT_TOPK = 8,
    VT_KEEPDIMS = 10,
    VT_AXISTYPE = 12
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool outMaxValue() const {
    return GetField<uint8_t>(VT_OUTMAXVALUE, 0) != 0;
  }
  int32_t topK() const {
    return GetField<int32_t>(VT_TOPK, 1);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  int32_t axisType() const {
    return GetField<int32_t>(VT_AXISTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<uint8_t>(verifier, VT_OUTMAXVALUE) &&
           VerifyField<int32_t>(verifier, VT_TOPK) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS) &&
           VerifyField<int32_t>(verifier, VT_AXISTYPE) &&
           verifier.EndTable();
  }
};

struct ArgMinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMin::VT_AXIS, axis, 0);
  }
  void add_outMaxValue(bool outMaxValue) {
    fbb_.AddElement<uint8_t>(ArgMin::VT_OUTMAXVALUE, static_cast<uint8_t>(outMaxValue), 0);
  }
  void add_topK(int32_t topK) {
    fbb_.AddElement<int32_t>(ArgMin::VT_TOPK, topK, 1);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(ArgMin::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  void add_axisType(int32_t axisType) {
    fbb_.AddElement<int32_t>(ArgMin::VT_AXISTYPE, axisType, 0);
  }
  explicit ArgMinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMinBuilder &operator=(const ArgMinBuilder &);
  flatbuffers::Offset<ArgMin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMin>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMin> CreateArgMin(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    bool outMaxValue = false,
    int32_t topK = 1,
    bool keepDims = false,
    int32_t axisType = 0) {
  ArgMinBuilder builder_(_fbb);
  builder_.add_axisType(axisType);
  builder_.add_topK(topK);
  builder_.add_axis(axis);
  builder_.add_keepDims(keepDims);
  builder_.add_outMaxValue(outMaxValue);
  return builder_.Finish();
}

struct NetOutput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NetOutputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NetOutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NetOutputBuilder &operator=(const NetOutputBuilder &);
  flatbuffers::Offset<NetOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NetOutput>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetOutput> CreateNetOutput(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NetOutputBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MatMul FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSPOSEA = 4,
    VT_TRANSPOSEB = 6
  };
  bool transposeA() const {
    return GetField<uint8_t>(VT_TRANSPOSEA, 0) != 0;
  }
  bool transposeB() const {
    return GetField<uint8_t>(VT_TRANSPOSEB, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSEA) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSEB) &&
           verifier.EndTable();
  }
};

struct MatMulBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transposeA(bool transposeA) {
    fbb_.AddElement<uint8_t>(MatMul::VT_TRANSPOSEA, static_cast<uint8_t>(transposeA), 0);
  }
  void add_transposeB(bool transposeB) {
    fbb_.AddElement<uint8_t>(MatMul::VT_TRANSPOSEB, static_cast<uint8_t>(transposeB), 0);
  }
  explicit MatMulBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatMulBuilder &operator=(const MatMulBuilder &);
  flatbuffers::Offset<MatMul> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatMul>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatMul> CreateMatMul(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool transposeA = false,
    bool transposeB = false) {
  MatMulBuilder builder_(_fbb);
  builder_.add_transposeB(transposeB);
  builder_.add_transposeA(transposeA);
  return builder_.Finish();
}

struct CaffePReLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELSHARED = 4
  };
  bool channelShared() const {
    return GetField<uint8_t>(VT_CHANNELSHARED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELSHARED) &&
           verifier.EndTable();
  }
};

struct CaffePReLUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channelShared(bool channelShared) {
    fbb_.AddElement<uint8_t>(CaffePReLU::VT_CHANNELSHARED, static_cast<uint8_t>(channelShared), 0);
  }
  explicit CaffePReLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CaffePReLUBuilder &operator=(const CaffePReLUBuilder &);
  flatbuffers::Offset<CaffePReLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CaffePReLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<CaffePReLU> CreateCaffePReLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool channelShared = false) {
  CaffePReLUBuilder builder_(_fbb);
  builder_.add_channelShared(channelShared);
  return builder_.Finish();
}

struct LeakyReLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEGATIVESLOPE = 4
  };
  float negativeSlope() const {
    return GetField<float>(VT_NEGATIVESLOPE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_NEGATIVESLOPE) &&
           verifier.EndTable();
  }
};

struct LeakyReLUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_negativeSlope(float negativeSlope) {
    fbb_.AddElement<float>(LeakyReLU::VT_NEGATIVESLOPE, negativeSlope, 0.0f);
  }
  explicit LeakyReLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeakyReLUBuilder &operator=(const LeakyReLUBuilder &);
  flatbuffers::Offset<LeakyReLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReLU> CreateLeakyReLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    float negativeSlope = 0.0f) {
  LeakyReLUBuilder builder_(_fbb);
  builder_.add_negativeSlope(negativeSlope);
  return builder_.Finish();
}

struct StridedSlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGINMASK = 4,
    VT_ENDMASK = 6,
    VT_ELLIPSISMASK = 8,
    VT_NEWAXISMASK = 10,
    VT_SHRINKAXISMASK = 12,
    VT_BEGIN = 14,
    VT_END = 16,
    VT_STRIDE = 18,
    VT_ISSCALE = 20
  };
  int32_t beginMask() const {
    return GetField<int32_t>(VT_BEGINMASK, 0);
  }
  int32_t endMask() const {
    return GetField<int32_t>(VT_ENDMASK, 0);
  }
  int32_t ellipsisMask() const {
    return GetField<int32_t>(VT_ELLIPSISMASK, 0);
  }
  int32_t newAxisMask() const {
    return GetField<int32_t>(VT_NEWAXISMASK, 0);
  }
  int32_t shrinkAxisMask() const {
    return GetField<int32_t>(VT_SHRINKAXISMASK, 0);
  }
  const flatbuffers::Vector<int32_t> *begin() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BEGIN);
  }
  const flatbuffers::Vector<int32_t> *end() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_END);
  }
  const flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int32_t> *isScale() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ISSCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BEGINMASK) &&
           VerifyField<int32_t>(verifier, VT_ENDMASK) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSISMASK) &&
           VerifyField<int32_t>(verifier, VT_NEWAXISMASK) &&
           VerifyField<int32_t>(verifier, VT_SHRINKAXISMASK) &&
           VerifyOffset(verifier, VT_BEGIN) &&
           verifier.VerifyVector(begin()) &&
           VerifyOffset(verifier, VT_END) &&
           verifier.VerifyVector(end()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_ISSCALE) &&
           verifier.VerifyVector(isScale()) &&
           verifier.EndTable();
  }
};

struct StridedSliceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beginMask(int32_t beginMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_BEGINMASK, beginMask, 0);
  }
  void add_endMask(int32_t endMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_ENDMASK, endMask, 0);
  }
  void add_ellipsisMask(int32_t ellipsisMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_ELLIPSISMASK, ellipsisMask, 0);
  }
  void add_newAxisMask(int32_t newAxisMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_NEWAXISMASK, newAxisMask, 0);
  }
  void add_shrinkAxisMask(int32_t shrinkAxisMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_SHRINKAXISMASK, shrinkAxisMask, 0);
  }
  void add_begin(flatbuffers::Offset<flatbuffers::Vector<int32_t>> begin) {
    fbb_.AddOffset(StridedSlice::VT_BEGIN, begin);
  }
  void add_end(flatbuffers::Offset<flatbuffers::Vector<int32_t>> end) {
    fbb_.AddOffset(StridedSlice::VT_END, end);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(StridedSlice::VT_STRIDE, stride);
  }
  void add_isScale(flatbuffers::Offset<flatbuffers::Vector<int32_t>> isScale) {
    fbb_.AddOffset(StridedSlice::VT_ISSCALE, isScale);
  }
  explicit StridedSliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StridedSliceBuilder &operator=(const StridedSliceBuilder &);
  flatbuffers::Offset<StridedSlice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSlice>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSlice> CreateStridedSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t beginMask = 0,
    int32_t endMask = 0,
    int32_t ellipsisMask = 0,
    int32_t newAxisMask = 0,
    int32_t shrinkAxisMask = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> begin = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> end = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> isScale = 0) {
  StridedSliceBuilder builder_(_fbb);
  builder_.add_isScale(isScale);
  builder_.add_stride(stride);
  builder_.add_end(end);
  builder_.add_begin(begin);
  builder_.add_shrinkAxisMask(shrinkAxisMask);
  builder_.add_newAxisMask(newAxisMask);
  builder_.add_ellipsisMask(ellipsisMask);
  builder_.add_endMask(endMask);
  builder_.add_beginMask(beginMask);
  return builder_.Finish();
}

inline flatbuffers::Offset<StridedSlice> CreateStridedSliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t beginMask = 0,
    int32_t endMask = 0,
    int32_t ellipsisMask = 0,
    int32_t newAxisMask = 0,
    int32_t shrinkAxisMask = 0,
    const std::vector<int32_t> *begin = nullptr,
    const std::vector<int32_t> *end = nullptr,
    const std::vector<int32_t> *stride = nullptr,
    const std::vector<int32_t> *isScale = nullptr) {
  auto begin__ = begin ? _fbb.CreateVector<int32_t>(*begin) : 0;
  auto end__ = end ? _fbb.CreateVector<int32_t>(*end) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  auto isScale__ = isScale ? _fbb.CreateVector<int32_t>(*isScale) : 0;
  return mindspore::schema::CreateStridedSlice(
      _fbb,
      beginMask,
      endMask,
      ellipsisMask,
      newAxisMask,
      shrinkAxisMask,
      begin__,
      end__,
      stride__,
      isScale__);
}

struct Stack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_N = 6,
    VT_ISSCALE = 8
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t n() const {
    return GetField<int32_t>(VT_N, 0);
  }
  const flatbuffers::Vector<int32_t> *isScale() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ISSCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_N) &&
           VerifyOffset(verifier, VT_ISSCALE) &&
           verifier.VerifyVector(isScale()) &&
           verifier.EndTable();
  }
};

struct StackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Stack::VT_AXIS, axis, 0);
  }
  void add_n(int32_t n) {
    fbb_.AddElement<int32_t>(Stack::VT_N, n, 0);
  }
  void add_isScale(flatbuffers::Offset<flatbuffers::Vector<int32_t>> isScale) {
    fbb_.AddOffset(Stack::VT_ISSCALE, isScale);
  }
  explicit StackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StackBuilder &operator=(const StackBuilder &);
  flatbuffers::Offset<Stack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Stack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Stack> CreateStack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t n = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> isScale = 0) {
  StackBuilder builder_(_fbb);
  builder_.add_isScale(isScale);
  builder_.add_n(n);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Stack> CreateStackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t n = 0,
    const std::vector<int32_t> *isScale = nullptr) {
  auto isScale__ = isScale ? _fbb.CreateVector<int32_t>(*isScale) : 0;
  return mindspore::schema::CreateStack(
      _fbb,
      axis,
      n,
      isScale__);
}

struct Range FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DTYPE = 4,
    VT_START = 6,
    VT_LIMIT = 8,
    VT_DELTA = 10
  };
  int32_t dType() const {
    return GetField<int32_t>(VT_DTYPE, 0);
  }
  int32_t start() const {
    return GetField<int32_t>(VT_START, 0);
  }
  int32_t limit() const {
    return GetField<int32_t>(VT_LIMIT, 0);
  }
  int32_t delta() const {
    return GetField<int32_t>(VT_DELTA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DTYPE) &&
           VerifyField<int32_t>(verifier, VT_START) &&
           VerifyField<int32_t>(verifier, VT_LIMIT) &&
           VerifyField<int32_t>(verifier, VT_DELTA) &&
           verifier.EndTable();
  }
};

struct RangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dType(int32_t dType) {
    fbb_.AddElement<int32_t>(Range::VT_DTYPE, dType, 0);
  }
  void add_start(int32_t start) {
    fbb_.AddElement<int32_t>(Range::VT_START, start, 0);
  }
  void add_limit(int32_t limit) {
    fbb_.AddElement<int32_t>(Range::VT_LIMIT, limit, 0);
  }
  void add_delta(int32_t delta) {
    fbb_.AddElement<int32_t>(Range::VT_DELTA, delta, 0);
  }
  explicit RangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeBuilder &operator=(const RangeBuilder &);
  flatbuffers::Offset<Range> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Range>(end);
    return o;
  }
};

inline flatbuffers::Offset<Range> CreateRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dType = 0,
    int32_t start = 0,
    int32_t limit = 0,
    int32_t delta = 0) {
  RangeBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_limit(limit);
  builder_.add_start(start);
  builder_.add_dType(dType);
  return builder_.Finish();
}

struct ExpandDims FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4
  };
  int32_t dim() const {
    return GetField<int32_t>(VT_DIM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DIM) &&
           verifier.EndTable();
  }
};

struct ExpandDimsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dim(int32_t dim) {
    fbb_.AddElement<int32_t>(ExpandDims::VT_DIM, dim, 0);
  }
  explicit ExpandDimsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpandDimsBuilder &operator=(const ExpandDimsBuilder &);
  flatbuffers::Offset<ExpandDims> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDims>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dim = 0) {
  ExpandDimsBuilder builder_(_fbb);
  builder_.add_dim(dim);
  return builder_.Finish();
}

struct Tile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MULTIPLES = 4
  };
  const flatbuffers::Vector<int32_t> *multiples() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MULTIPLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MULTIPLES) &&
           verifier.VerifyVector(multiples()) &&
           verifier.EndTable();
  }
};

struct TileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_multiples(flatbuffers::Offset<flatbuffers::Vector<int32_t>> multiples) {
    fbb_.AddOffset(Tile::VT_MULTIPLES, multiples);
  }
  explicit TileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TileBuilder &operator=(const TileBuilder &);
  flatbuffers::Offset<Tile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tile>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tile> CreateTile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> multiples = 0) {
  TileBuilder builder_(_fbb);
  builder_.add_multiples(multiples);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tile> CreateTileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *multiples = nullptr) {
  auto multiples__ = multiples ? _fbb.CreateVector<int32_t>(*multiples) : 0;
  return mindspore::schema::CreateTile(
      _fbb,
      multiples__);
}

struct Cast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCT = 4,
    VT_DSTT = 6
  };
  int32_t srcT() const {
    return GetField<int32_t>(VT_SRCT, 0);
  }
  int32_t dstT() const {
    return GetField<int32_t>(VT_DSTT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCT) &&
           VerifyField<int32_t>(verifier, VT_DSTT) &&
           verifier.EndTable();
  }
};

struct CastBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_srcT(int32_t srcT) {
    fbb_.AddElement<int32_t>(Cast::VT_SRCT, srcT, 0);
  }
  void add_dstT(int32_t dstT) {
    fbb_.AddElement<int32_t>(Cast::VT_DSTT, dstT, 0);
  }
  explicit CastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CastBuilder &operator=(const CastBuilder &);
  flatbuffers::Offset<Cast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cast>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cast> CreateCast(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t srcT = 0,
    int32_t dstT = 0) {
  CastBuilder builder_(_fbb);
  builder_.add_dstT(dstT);
  builder_.add_srcT(srcT);
  return builder_.Finish();
}

struct QuantDTypeCast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCT = 4,
    VT_DSTT = 6
  };
  int32_t srcT() const {
    return GetField<int32_t>(VT_SRCT, 0);
  }
  int32_t dstT() const {
    return GetField<int32_t>(VT_DSTT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCT) &&
           VerifyField<int32_t>(verifier, VT_DSTT) &&
           verifier.EndTable();
  }
};

struct QuantDTypeCastBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_srcT(int32_t srcT) {
    fbb_.AddElement<int32_t>(QuantDTypeCast::VT_SRCT, srcT, 0);
  }
  void add_dstT(int32_t dstT) {
    fbb_.AddElement<int32_t>(QuantDTypeCast::VT_DSTT, dstT, 0);
  }
  explicit QuantDTypeCastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantDTypeCastBuilder &operator=(const QuantDTypeCastBuilder &);
  flatbuffers::Offset<QuantDTypeCast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantDTypeCast>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t srcT = 0,
    int32_t dstT = 0) {
  QuantDTypeCastBuilder builder_(_fbb);
  builder_.add_dstT(dstT);
  builder_.add_srcT(srcT);
  return builder_.Finish();
}

struct Split FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBERSPLIT = 4,
    VT_SIZESPLITS = 6,
    VT_SPLITDIM = 8
  };
  int32_t numberSplit() const {
    return GetField<int32_t>(VT_NUMBERSPLIT, 0);
  }
  const flatbuffers::Vector<int32_t> *sizeSplits() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZESPLITS);
  }
  int32_t splitDim() const {
    return GetField<int32_t>(VT_SPLITDIM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMBERSPLIT) &&
           VerifyOffset(verifier, VT_SIZESPLITS) &&
           verifier.VerifyVector(sizeSplits()) &&
           VerifyField<int32_t>(verifier, VT_SPLITDIM) &&
           verifier.EndTable();
  }
};

struct SplitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numberSplit(int32_t numberSplit) {
    fbb_.AddElement<int32_t>(Split::VT_NUMBERSPLIT, numberSplit, 0);
  }
  void add_sizeSplits(flatbuffers::Offset<flatbuffers::Vector<int32_t>> sizeSplits) {
    fbb_.AddOffset(Split::VT_SIZESPLITS, sizeSplits);
  }
  void add_splitDim(int32_t splitDim) {
    fbb_.AddElement<int32_t>(Split::VT_SPLITDIM, splitDim, 0);
  }
  explicit SplitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitBuilder &operator=(const SplitBuilder &);
  flatbuffers::Offset<Split> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Split>(end);
    return o;
  }
};

inline flatbuffers::Offset<Split> CreateSplit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numberSplit = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> sizeSplits = 0,
    int32_t splitDim = 0) {
  SplitBuilder builder_(_fbb);
  builder_.add_splitDim(splitDim);
  builder_.add_sizeSplits(sizeSplits);
  builder_.add_numberSplit(numberSplit);
  return builder_.Finish();
}

inline flatbuffers::Offset<Split> CreateSplitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numberSplit = 0,
    const std::vector<int32_t> *sizeSplits = nullptr,
    int32_t splitDim = 0) {
  auto sizeSplits__ = sizeSplits ? _fbb.CreateVector<int32_t>(*sizeSplits) : 0;
  return mindspore::schema::CreateSplit(
      _fbb,
      numberSplit,
      sizeSplits__,
      splitDim);
}

struct Crop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OFFSETS = 6
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  const flatbuffers::Vector<int64_t> *offsets() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OFFSETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyOffset(verifier, VT_OFFSETS) &&
           verifier.VerifyVector(offsets()) &&
           verifier.EndTable();
  }
};

struct CropBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Crop::VT_AXIS, axis, 0);
  }
  void add_offsets(flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets) {
    fbb_.AddOffset(Crop::VT_OFFSETS, offsets);
  }
  explicit CropBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CropBuilder &operator=(const CropBuilder &);
  flatbuffers::Offset<Crop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Crop>(end);
    return o;
  }
};

inline flatbuffers::Offset<Crop> CreateCrop(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets = 0) {
  CropBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_offsets(offsets);
  return builder_.Finish();
}

inline flatbuffers::Offset<Crop> CreateCropDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    const std::vector<int64_t> *offsets = nullptr) {
  auto offsets__ = offsets ? _fbb.CreateVector<int64_t>(*offsets) : 0;
  return mindspore::schema::CreateCrop(
      _fbb,
      axis,
      offsets__);
}

struct Permute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORDER = 4
  };
  const flatbuffers::Vector<int64_t> *order() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ORDER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORDER) &&
           verifier.VerifyVector(order()) &&
           verifier.EndTable();
  }
};

struct PermuteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_order(flatbuffers::Offset<flatbuffers::Vector<int64_t>> order) {
    fbb_.AddOffset(Permute::VT_ORDER, order);
  }
  explicit PermuteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PermuteBuilder &operator=(const PermuteBuilder &);
  flatbuffers::Offset<Permute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Permute>(end);
    return o;
  }
};

inline flatbuffers::Offset<Permute> CreatePermute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> order = 0) {
  PermuteBuilder builder_(_fbb);
  builder_.add_order(order);
  return builder_.Finish();
}

inline flatbuffers::Offset<Permute> CreatePermuteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *order = nullptr) {
  auto order__ = order ? _fbb.CreateVector<int64_t>(*order) : 0;
  return mindspore::schema::CreatePermute(
      _fbb,
      order__);
}

struct Clip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAX = 4,
    VT_MIN = 6
  };
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MAX) &&
           VerifyField<float>(verifier, VT_MIN) &&
           verifier.EndTable();
  }
};

struct ClipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_max(float max) {
    fbb_.AddElement<float>(Clip::VT_MAX, max, 0.0f);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(Clip::VT_MIN, min, 0.0f);
  }
  explicit ClipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClipBuilder &operator=(const ClipBuilder &);
  flatbuffers::Offset<Clip> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Clip>(end);
    return o;
  }
};

inline flatbuffers::Offset<Clip> CreateClip(
    flatbuffers::FlatBufferBuilder &_fbb,
    float max = 0.0f,
    float min = 0.0f) {
  ClipBuilder builder_(_fbb);
  builder_.add_min(min);
  builder_.add_max(max);
  return builder_.Finish();
}

struct Constant FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ConstantBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ConstantBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConstantBuilder &operator=(const ConstantBuilder &);
  flatbuffers::Offset<Constant> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Constant>(end);
    return o;
  }
};

inline flatbuffers::Offset<Constant> CreateConstant(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ConstantBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Elu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
};

struct EluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Elu::VT_ALPHA, alpha, 1.0f);
  }
  explicit EluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EluBuilder &operator=(const EluBuilder &);
  flatbuffers::Offset<Elu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Elu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Elu> CreateElu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 1.0f) {
  EluBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct Broadcast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BroadcastBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BroadcastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BroadcastBuilder &operator=(const BroadcastBuilder &);
  flatbuffers::Offset<Broadcast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Broadcast>(end);
    return o;
  }
};

inline flatbuffers::Offset<Broadcast> CreateBroadcast(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BroadcastBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BroadcastTo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DST_SHAPE = 4
  };
  const flatbuffers::Vector<int32_t> *dst_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DST_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DST_SHAPE) &&
           verifier.VerifyVector(dst_shape()) &&
           verifier.EndTable();
  }
};

struct BroadcastToBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dst_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dst_shape) {
    fbb_.AddOffset(BroadcastTo::VT_DST_SHAPE, dst_shape);
  }
  explicit BroadcastToBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BroadcastToBuilder &operator=(const BroadcastToBuilder &);
  flatbuffers::Offset<BroadcastTo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadcastTo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dst_shape = 0) {
  BroadcastToBuilder builder_(_fbb);
  builder_.add_dst_shape(dst_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<BroadcastTo> CreateBroadcastToDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dst_shape = nullptr) {
  auto dst_shape__ = dst_shape ? _fbb.CreateVector<int32_t>(*dst_shape) : 0;
  return mindspore::schema::CreateBroadcastTo(
      _fbb,
      dst_shape__);
}

struct Lrn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4,
    VT_BETA = 6,
    VT_BIAS = 8,
    VT_SIZE = 10
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0001f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.75f);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 1.0f);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct LrnBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Lrn::VT_ALPHA, alpha, 0.0001f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(Lrn::VT_BETA, beta, 0.75f);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(Lrn::VT_BIAS, bias, 1.0f);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(Lrn::VT_SIZE, size, 0);
  }
  explicit LrnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LrnBuilder &operator=(const LrnBuilder &);
  flatbuffers::Offset<Lrn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lrn>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lrn> CreateLrn(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0001f,
    float beta = 0.75f,
    float bias = 1.0f,
    int32_t size = 0) {
  LrnBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_bias(bias);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct Reduce FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXES = 4,
    VT_KEEPDIMS = 6,
    VT_MODE = 8
  };
  const flatbuffers::Vector<int32_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  int32_t keepDims() const {
    return GetField<int32_t>(VT_KEEPDIMS, 0);
  }
  ReduceMode mode() const {
    return static_cast<ReduceMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           VerifyField<int32_t>(verifier, VT_KEEPDIMS) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
};

struct ReduceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes) {
    fbb_.AddOffset(Reduce::VT_AXES, axes);
  }
  void add_keepDims(int32_t keepDims) {
    fbb_.AddElement<int32_t>(Reduce::VT_KEEPDIMS, keepDims, 0);
  }
  void add_mode(ReduceMode mode) {
    fbb_.AddElement<int8_t>(Reduce::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit ReduceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReduceBuilder &operator=(const ReduceBuilder &);
  flatbuffers::Offset<Reduce> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reduce>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reduce> CreateReduce(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes = 0,
    int32_t keepDims = 0,
    ReduceMode mode = ReduceMode_ReduceMean) {
  ReduceBuilder builder_(_fbb);
  builder_.add_keepDims(keepDims);
  builder_.add_axes(axes);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reduce> CreateReduceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axes = nullptr,
    int32_t keepDims = 0,
    ReduceMode mode = ReduceMode_ReduceMean) {
  auto axes__ = axes ? _fbb.CreateVector<int32_t>(*axes) : 0;
  return mindspore::schema::CreateReduce(
      _fbb,
      axes__,
      keepDims,
      mode);
}

struct Prelu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPE = 4
  };
  const flatbuffers::Vector<float> *slope() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SLOPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SLOPE) &&
           verifier.VerifyVector(slope()) &&
           verifier.EndTable();
  }
};

struct PreluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slope(flatbuffers::Offset<flatbuffers::Vector<float>> slope) {
    fbb_.AddOffset(Prelu::VT_SLOPE, slope);
  }
  explicit PreluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PreluBuilder &operator=(const PreluBuilder &);
  flatbuffers::Offset<Prelu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Prelu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Prelu> CreatePrelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> slope = 0) {
  PreluBuilder builder_(_fbb);
  builder_.add_slope(slope);
  return builder_.Finish();
}

inline flatbuffers::Offset<Prelu> CreatePreluDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *slope = nullptr) {
  auto slope__ = slope ? _fbb.CreateVector<float>(*slope) : 0;
  return mindspore::schema::CreatePrelu(
      _fbb,
      slope__);
}

struct Transpose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERM = 4,
    VT_CONJUGATE = 6
  };
  const flatbuffers::Vector<int32_t> *perm() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PERM);
  }
  bool conjugate() const {
    return GetField<uint8_t>(VT_CONJUGATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PERM) &&
           verifier.VerifyVector(perm()) &&
           VerifyField<uint8_t>(verifier, VT_CONJUGATE) &&
           verifier.EndTable();
  }
};

struct TransposeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_perm(flatbuffers::Offset<flatbuffers::Vector<int32_t>> perm) {
    fbb_.AddOffset(Transpose::VT_PERM, perm);
  }
  void add_conjugate(bool conjugate) {
    fbb_.AddElement<uint8_t>(Transpose::VT_CONJUGATE, static_cast<uint8_t>(conjugate), 0);
  }
  explicit TransposeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeBuilder &operator=(const TransposeBuilder &);
  flatbuffers::Offset<Transpose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transpose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Transpose> CreateTranspose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> perm = 0,
    bool conjugate = false) {
  TransposeBuilder builder_(_fbb);
  builder_.add_perm(perm);
  builder_.add_conjugate(conjugate);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transpose> CreateTransposeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *perm = nullptr,
    bool conjugate = false) {
  auto perm__ = perm ? _fbb.CreateVector<int32_t>(*perm) : 0;
  return mindspore::schema::CreateTranspose(
      _fbb,
      perm__,
      conjugate);
}

struct Squeeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct SqueezeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(Squeeze::VT_AXIS, axis);
  }
  explicit SqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqueezeBuilder &operator=(const SqueezeBuilder &);
  flatbuffers::Offset<Squeeze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Squeeze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Squeeze> CreateSqueeze(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  SqueezeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Squeeze> CreateSqueezeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateSqueeze(
      _fbb,
      axis__);
}

struct Unsqueeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct UnsqueezeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(Unsqueeze::VT_AXIS, axis);
  }
  explicit UnsqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnsqueezeBuilder &operator=(const UnsqueezeBuilder &);
  flatbuffers::Offset<Unsqueeze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unsqueeze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  UnsqueezeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unsqueeze> CreateUnsqueezeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateUnsqueeze(
      _fbb,
      axis__);
}

struct Upsample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_SCALES = 6
  };
  const flatbuffers::String *mode() const {
    return GetPointer<const flatbuffers::String *>(VT_MODE);
  }
  const flatbuffers::Vector<float> *scales() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyVector(scales()) &&
           verifier.EndTable();
  }
};

struct UpsampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(flatbuffers::Offset<flatbuffers::String> mode) {
    fbb_.AddOffset(Upsample::VT_MODE, mode);
  }
  void add_scales(flatbuffers::Offset<flatbuffers::Vector<float>> scales) {
    fbb_.AddOffset(Upsample::VT_SCALES, scales);
  }
  explicit UpsampleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpsampleBuilder &operator=(const UpsampleBuilder &);
  flatbuffers::Offset<Upsample> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Upsample>(end);
    return o;
  }
};

inline flatbuffers::Offset<Upsample> CreateUpsample(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mode = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scales = 0) {
  UpsampleBuilder builder_(_fbb);
  builder_.add_scales(scales);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Upsample> CreateUpsampleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mode = nullptr,
    const std::vector<float> *scales = nullptr) {
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  auto scales__ = scales ? _fbb.CreateVector<float>(*scales) : 0;
  return mindspore::schema::CreateUpsample(
      _fbb,
      mode__,
      scales__);
}

struct Dropout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATIO = 4
  };
  float ratio() const {
    return GetField<float>(VT_RATIO, 0.5f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATIO) &&
           verifier.EndTable();
  }
};

struct DropoutBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ratio(float ratio) {
    fbb_.AddElement<float>(Dropout::VT_RATIO, ratio, 0.5f);
  }
  explicit DropoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DropoutBuilder &operator=(const DropoutBuilder &);
  flatbuffers::Offset<Dropout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dropout>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dropout> CreateDropout(
    flatbuffers::FlatBufferBuilder &_fbb,
    float ratio = 0.5f) {
  DropoutBuilder builder_(_fbb);
  builder_.add_ratio(ratio);
  return builder_.Finish();
}

struct LocalResponseNormalization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEPTH_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10
  };
  int32_t depth_radius() const {
    return GetField<int32_t>(VT_DEPTH_RADIUS, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_RADIUS) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
};

struct LocalResponseNormalizationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_depth_radius(int32_t depth_radius) {
    fbb_.AddElement<int32_t>(LocalResponseNormalization::VT_DEPTH_RADIUS, depth_radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LocalResponseNormalization::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LocalResponseNormalization::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LocalResponseNormalization::VT_BETA, beta, 0.0f);
  }
  explicit LocalResponseNormalizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LocalResponseNormalizationBuilder &operator=(const LocalResponseNormalizationBuilder &);
  flatbuffers::Offset<LocalResponseNormalization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalResponseNormalization>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalResponseNormalization> CreateLocalResponseNormalization(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t depth_radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LocalResponseNormalizationBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_depth_radius(depth_radius);
  return builder_.Finish();
}

struct ZerosLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ZerosLikeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ZerosLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ZerosLikeBuilder &operator=(const ZerosLikeBuilder &);
  flatbuffers::Offset<ZerosLike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ZerosLike>(end);
    return o;
  }
};

inline flatbuffers::Offset<ZerosLike> CreateZerosLike(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ZerosLikeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TopK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_K = 4,
    VT_SORTED = 6
  };
  int32_t k() const {
    return GetField<int32_t>(VT_K, 0);
  }
  bool sorted() const {
    return GetField<uint8_t>(VT_SORTED, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_K) &&
           VerifyField<uint8_t>(verifier, VT_SORTED) &&
           verifier.EndTable();
  }
};

struct TopKBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_k(int32_t k) {
    fbb_.AddElement<int32_t>(TopK::VT_K, k, 0);
  }
  void add_sorted(bool sorted) {
    fbb_.AddElement<uint8_t>(TopK::VT_SORTED, static_cast<uint8_t>(sorted), 1);
  }
  explicit TopKBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopKBuilder &operator=(const TopKBuilder &);
  flatbuffers::Offset<TopK> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopK>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopK> CreateTopK(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t k = 0,
    bool sorted = true) {
  TopKBuilder builder_(_fbb);
  builder_.add_k(k);
  builder_.add_sorted(sorted);
  return builder_.Finish();
}

struct SpaceToDepth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSIZE = 4,
    VT_FORMAT = 6
  };
  int32_t blockSize() const {
    return GetField<int32_t>(VT_BLOCKSIZE, 0);
  }
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCKSIZE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
};

struct SpaceToDepthBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockSize(int32_t blockSize) {
    fbb_.AddElement<int32_t>(SpaceToDepth::VT_BLOCKSIZE, blockSize, 0);
  }
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(SpaceToDepth::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit SpaceToDepthBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToDepthBuilder &operator=(const SpaceToDepthBuilder &);
  flatbuffers::Offset<SpaceToDepth> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToDepth>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t blockSize = 0,
    Format format = Format_NCHW) {
  SpaceToDepthBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_blockSize(blockSize);
  return builder_.Finish();
}

struct SpaceToBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_PADDINGS = 6
  };
  const flatbuffers::Vector<int32_t> *blockShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  const flatbuffers::Vector<int32_t> *paddings() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyVector(blockShape()) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyVector(paddings()) &&
           verifier.EndTable();
  }
};

struct SpaceToBatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape) {
    fbb_.AddOffset(SpaceToBatch::VT_BLOCKSHAPE, blockShape);
  }
  void add_paddings(flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings) {
    fbb_.AddOffset(SpaceToBatch::VT_PADDINGS, paddings);
  }
  explicit SpaceToBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToBatchBuilder &operator=(const SpaceToBatchBuilder &);
  flatbuffers::Offset<SpaceToBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings = 0) {
  SpaceToBatchBuilder builder_(_fbb);
  builder_.add_paddings(paddings);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *blockShape = nullptr,
    const std::vector<int32_t> *paddings = nullptr) {
  auto blockShape__ = blockShape ? _fbb.CreateVector<int32_t>(*blockShape) : 0;
  auto paddings__ = paddings ? _fbb.CreateVector<int32_t>(*paddings) : 0;
  return mindspore::schema::CreateSpaceToBatch(
      _fbb,
      blockShape__,
      paddings__);
}

struct SparseToDense FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTSHAPE = 4,
    VT_SPARSEVALUE = 6,
    VT_DEFAULTVALUE = 8,
    VT_VALIDATEINDICES = 10
  };
  const flatbuffers::Vector<int32_t> *outputShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTSHAPE);
  }
  const flatbuffers::Vector<int32_t> *sparseValue() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SPARSEVALUE);
  }
  const flatbuffers::Vector<int32_t> *defaultValue() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DEFAULTVALUE);
  }
  bool validateIndices() const {
    return GetField<uint8_t>(VT_VALIDATEINDICES, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUTPUTSHAPE) &&
           verifier.VerifyVector(outputShape()) &&
           VerifyOffset(verifier, VT_SPARSEVALUE) &&
           verifier.VerifyVector(sparseValue()) &&
           VerifyOffset(verifier, VT_DEFAULTVALUE) &&
           verifier.VerifyVector(defaultValue()) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATEINDICES) &&
           verifier.EndTable();
  }
};

struct SparseToDenseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputShape) {
    fbb_.AddOffset(SparseToDense::VT_OUTPUTSHAPE, outputShape);
  }
  void add_sparseValue(flatbuffers::Offset<flatbuffers::Vector<int32_t>> sparseValue) {
    fbb_.AddOffset(SparseToDense::VT_SPARSEVALUE, sparseValue);
  }
  void add_defaultValue(flatbuffers::Offset<flatbuffers::Vector<int32_t>> defaultValue) {
    fbb_.AddOffset(SparseToDense::VT_DEFAULTVALUE, defaultValue);
  }
  void add_validateIndices(bool validateIndices) {
    fbb_.AddElement<uint8_t>(SparseToDense::VT_VALIDATEINDICES, static_cast<uint8_t>(validateIndices), 0);
  }
  explicit SparseToDenseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparseToDenseBuilder &operator=(const SparseToDenseBuilder &);
  flatbuffers::Offset<SparseToDense> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseToDense>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseToDense> CreateSparseToDense(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputShape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> sparseValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> defaultValue = 0,
    bool validateIndices = false) {
  SparseToDenseBuilder builder_(_fbb);
  builder_.add_defaultValue(defaultValue);
  builder_.add_sparseValue(sparseValue);
  builder_.add_outputShape(outputShape);
  builder_.add_validateIndices(validateIndices);
  return builder_.Finish();
}

inline flatbuffers::Offset<SparseToDense> CreateSparseToDenseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *outputShape = nullptr,
    const std::vector<int32_t> *sparseValue = nullptr,
    const std::vector<int32_t> *defaultValue = nullptr,
    bool validateIndices = false) {
  auto outputShape__ = outputShape ? _fbb.CreateVector<int32_t>(*outputShape) : 0;
  auto sparseValue__ = sparseValue ? _fbb.CreateVector<int32_t>(*sparseValue) : 0;
  auto defaultValue__ = defaultValue ? _fbb.CreateVector<int32_t>(*defaultValue) : 0;
  return mindspore::schema::CreateSparseToDense(
      _fbb,
      outputShape__,
      sparseValue__,
      defaultValue__,
      validateIndices);
}

struct ReverseSequence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQAXIS = 4,
    VT_BATCHAXIS = 6,
    VT_SEQLENGTHS = 8
  };
  int32_t seqAxis() const {
    return GetField<int32_t>(VT_SEQAXIS, 0);
  }
  int32_t batchAxis() const {
    return GetField<int32_t>(VT_BATCHAXIS, 0);
  }
  const flatbuffers::Vector<int32_t> *seqLengths() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SEQLENGTHS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEQAXIS) &&
           VerifyField<int32_t>(verifier, VT_BATCHAXIS) &&
           VerifyOffset(verifier, VT_SEQLENGTHS) &&
           verifier.VerifyVector(seqLengths()) &&
           verifier.EndTable();
  }
};

struct ReverseSequenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seqAxis(int32_t seqAxis) {
    fbb_.AddElement<int32_t>(ReverseSequence::VT_SEQAXIS, seqAxis, 0);
  }
  void add_batchAxis(int32_t batchAxis) {
    fbb_.AddElement<int32_t>(ReverseSequence::VT_BATCHAXIS, batchAxis, 0);
  }
  void add_seqLengths(flatbuffers::Offset<flatbuffers::Vector<int32_t>> seqLengths) {
    fbb_.AddOffset(ReverseSequence::VT_SEQLENGTHS, seqLengths);
  }
  explicit ReverseSequenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseSequenceBuilder &operator=(const ReverseSequenceBuilder &);
  flatbuffers::Offset<ReverseSequence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseSequence>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseSequence> CreateReverseSequence(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seqAxis = 0,
    int32_t batchAxis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> seqLengths = 0) {
  ReverseSequenceBuilder builder_(_fbb);
  builder_.add_seqLengths(seqLengths);
  builder_.add_batchAxis(batchAxis);
  builder_.add_seqAxis(seqAxis);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReverseSequence> CreateReverseSequenceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seqAxis = 0,
    int32_t batchAxis = 0,
    const std::vector<int32_t> *seqLengths = nullptr) {
  auto seqLengths__ = seqLengths ? _fbb.CreateVector<int32_t>(*seqLengths) : 0;
  return mindspore::schema::CreateReverseSequence(
      _fbb,
      seqAxis,
      batchAxis,
      seqLengths__);
}

struct Rank FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RankBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RankBuilder &operator=(const RankBuilder &);
  flatbuffers::Offset<Rank> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rank>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rank> CreateRank(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RankBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Gather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_BATCHDIMS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t batchDims() const {
    return GetField<int32_t>(VT_BATCHDIMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_BATCHDIMS) &&
           verifier.EndTable();
  }
};

struct GatherBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Gather::VT_AXIS, axis, 0);
  }
  void add_batchDims(int32_t batchDims) {
    fbb_.AddElement<int32_t>(Gather::VT_BATCHDIMS, batchDims, 0);
  }
  explicit GatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherBuilder &operator=(const GatherBuilder &);
  flatbuffers::Offset<Gather> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gather>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gather> CreateGather(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t batchDims = 0) {
  GatherBuilder builder_(_fbb);
  builder_.add_batchDims(batchDims);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct GatherNd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATCHDIMS = 4
  };
  int32_t batchDims() const {
    return GetField<int32_t>(VT_BATCHDIMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BATCHDIMS) &&
           verifier.EndTable();
  }
};

struct GatherNdBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_batchDims(int32_t batchDims) {
    fbb_.AddElement<int32_t>(GatherNd::VT_BATCHDIMS, batchDims, 0);
  }
  explicit GatherNdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherNdBuilder &operator=(const GatherNdBuilder &);
  flatbuffers::Offset<GatherNd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherNd>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherNd> CreateGatherNd(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t batchDims = 0) {
  GatherNdBuilder builder_(_fbb);
  builder_.add_batchDims(batchDims);
  return builder_.Finish();
}

struct Fill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
};

struct FillBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Fill::VT_DIMS, dims);
  }
  explicit FillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FillBuilder &operator=(const FillBuilder &);
  flatbuffers::Offset<Fill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fill>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fill> CreateFill(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0) {
  FillBuilder builder_(_fbb);
  builder_.add_dims(dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fill> CreateFillDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return mindspore::schema::CreateFill(
      _fbb,
      dims__);
}

struct DepthToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSIZE = 4,
    VT_FORMAT = 6
  };
  int32_t blockSize() const {
    return GetField<int32_t>(VT_BLOCKSIZE, 0);
  }
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCKSIZE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
};

struct DepthToSpaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockSize(int32_t blockSize) {
    fbb_.AddElement<int32_t>(DepthToSpace::VT_BLOCKSIZE, blockSize, 0);
  }
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(DepthToSpace::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit DepthToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthToSpaceBuilder &operator=(const DepthToSpaceBuilder &);
  flatbuffers::Offset<DepthToSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthToSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t blockSize = 0,
    Format format = Format_NCHW) {
  DepthToSpaceBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_blockSize(blockSize);
  return builder_.Finish();
}

struct BatchToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_CROPS = 6
  };
  const flatbuffers::Vector<int32_t> *blockShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  const flatbuffers::Vector<int32_t> *crops() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyVector(blockShape()) &&
           VerifyOffset(verifier, VT_CROPS) &&
           verifier.VerifyVector(crops()) &&
           verifier.EndTable();
  }
};

struct BatchToSpaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape) {
    fbb_.AddOffset(BatchToSpace::VT_BLOCKSHAPE, blockShape);
  }
  void add_crops(flatbuffers::Offset<flatbuffers::Vector<int32_t>> crops) {
    fbb_.AddOffset(BatchToSpace::VT_CROPS, crops);
  }
  explicit BatchToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchToSpaceBuilder &operator=(const BatchToSpaceBuilder &);
  flatbuffers::Offset<BatchToSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> crops = 0) {
  BatchToSpaceBuilder builder_(_fbb);
  builder_.add_crops(crops);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *blockShape = nullptr,
    const std::vector<int32_t> *crops = nullptr) {
  auto blockShape__ = blockShape ? _fbb.CreateVector<int32_t>(*blockShape) : 0;
  auto crops__ = crops ? _fbb.CreateVector<int32_t>(*crops) : 0;
  return mindspore::schema::CreateBatchToSpace(
      _fbb,
      blockShape__,
      crops__);
}

struct AddN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_N = 4
  };
  int32_t N() const {
    return GetField<int32_t>(VT_N, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_N) &&
           verifier.EndTable();
  }
};

struct AddNBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_N(int32_t N) {
    fbb_.AddElement<int32_t>(AddN::VT_N, N, 0);
  }
  explicit AddNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddNBuilder &operator=(const AddNBuilder &);
  flatbuffers::Offset<AddN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddN>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddN> CreateAddN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t N = 0) {
  AddNBuilder builder_(_fbb);
  builder_.add_N(N);
  return builder_.Finish();
}

struct EmbeddingLookup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDS = 4,
    VT_MAXNORM = 6
  };
  const flatbuffers::Vector<int32_t> *ids() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_IDS);
  }
  float maxNorm() const {
    return GetField<float>(VT_MAXNORM, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDS) &&
           verifier.VerifyVector(ids()) &&
           VerifyField<float>(verifier, VT_MAXNORM) &&
           verifier.EndTable();
  }
};

struct EmbeddingLookupBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ids) {
    fbb_.AddOffset(EmbeddingLookup::VT_IDS, ids);
  }
  void add_maxNorm(float maxNorm) {
    fbb_.AddElement<float>(EmbeddingLookup::VT_MAXNORM, maxNorm, 0.0f);
  }
  explicit EmbeddingLookupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmbeddingLookupBuilder &operator=(const EmbeddingLookupBuilder &);
  flatbuffers::Offset<EmbeddingLookup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookup>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookup> CreateEmbeddingLookup(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ids = 0,
    float maxNorm = 0.0f) {
  EmbeddingLookupBuilder builder_(_fbb);
  builder_.add_maxNorm(maxNorm);
  builder_.add_ids(ids);
  return builder_.Finish();
}

inline flatbuffers::Offset<EmbeddingLookup> CreateEmbeddingLookupDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *ids = nullptr,
    float maxNorm = 0.0f) {
  auto ids__ = ids ? _fbb.CreateVector<int32_t>(*ids) : 0;
  return mindspore::schema::CreateEmbeddingLookup(
      _fbb,
      ids__,
      maxNorm);
}

struct EmbeddingLookupSparse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPIDS = 4,
    VT_SPWEIGHTS = 6,
    VT_MAXNORTM = 8
  };
  const flatbuffers::Vector<int32_t> *spIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SPIDS);
  }
  const flatbuffers::Vector<float> *spWeights() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SPWEIGHTS);
  }
  float maxNortm() const {
    return GetField<float>(VT_MAXNORTM, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPIDS) &&
           verifier.VerifyVector(spIds()) &&
           VerifyOffset(verifier, VT_SPWEIGHTS) &&
           verifier.VerifyVector(spWeights()) &&
           VerifyField<float>(verifier, VT_MAXNORTM) &&
           verifier.EndTable();
  }
};

struct EmbeddingLookupSparseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_spIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> spIds) {
    fbb_.AddOffset(EmbeddingLookupSparse::VT_SPIDS, spIds);
  }
  void add_spWeights(flatbuffers::Offset<flatbuffers::Vector<float>> spWeights) {
    fbb_.AddOffset(EmbeddingLookupSparse::VT_SPWEIGHTS, spWeights);
  }
  void add_maxNortm(float maxNortm) {
    fbb_.AddElement<float>(EmbeddingLookupSparse::VT_MAXNORTM, maxNortm, 0.0f);
  }
  explicit EmbeddingLookupSparseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmbeddingLookupSparseBuilder &operator=(const EmbeddingLookupSparseBuilder &);
  flatbuffers::Offset<EmbeddingLookupSparse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookupSparse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookupSparse> CreateEmbeddingLookupSparse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> spIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> spWeights = 0,
    float maxNortm = 0.0f) {
  EmbeddingLookupSparseBuilder builder_(_fbb);
  builder_.add_maxNortm(maxNortm);
  builder_.add_spWeights(spWeights);
  builder_.add_spIds(spIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<EmbeddingLookupSparse> CreateEmbeddingLookupSparseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *spIds = nullptr,
    const std::vector<float> *spWeights = nullptr,
    float maxNortm = 0.0f) {
  auto spIds__ = spIds ? _fbb.CreateVector<int32_t>(*spIds) : 0;
  auto spWeights__ = spWeights ? _fbb.CreateVector<float>(*spWeights) : 0;
  return mindspore::schema::CreateEmbeddingLookupSparse(
      _fbb,
      spIds__,
      spWeights__,
      maxNortm);
}

struct FloorDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorDivBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorDivBuilder &operator=(const FloorDivBuilder &);
  flatbuffers::Offset<FloorDiv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorDiv>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorDiv> CreateFloorDiv(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorDivBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FloorMod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorModBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorModBuilder &operator=(const FloorModBuilder &);
  flatbuffers::Offset<FloorMod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorMod>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorMod> CreateFloorMod(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorModBuilder builder_(_fbb);
  return builder_.Finish();
}

struct L2Norm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_EPSILON = 6
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           verifier.EndTable();
  }
};

struct L2NormBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(L2Norm::VT_AXIS, axis);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(L2Norm::VT_EPSILON, epsilon, 0.0f);
  }
  explicit L2NormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  L2NormBuilder &operator=(const L2NormBuilder &);
  flatbuffers::Offset<L2Norm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<L2Norm>(end);
    return o;
  }
};

inline flatbuffers::Offset<L2Norm> CreateL2Norm(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0,
    float epsilon = 0.0f) {
  L2NormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<L2Norm> CreateL2NormDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr,
    float epsilon = 0.0f) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateL2Norm(
      _fbb,
      axis__,
      epsilon);
}

struct LogicalAnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalAndBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalAndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalAndBuilder &operator=(const LogicalAndBuilder &);
  flatbuffers::Offset<LogicalAnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalAndBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalOr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalOrBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalOrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalOrBuilder &operator=(const LogicalOrBuilder &);
  flatbuffers::Offset<LogicalOr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalOr>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalOr> CreateLogicalOr(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalOrBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalXor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalXorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalXorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalXorBuilder &operator=(const LogicalXorBuilder &);
  flatbuffers::Offset<LogicalXor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalXor>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalXor> CreateLogicalXor(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalXorBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalNot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalNotBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalNotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalNotBuilder &operator=(const LogicalNotBuilder &);
  flatbuffers::Offset<LogicalNot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalNot>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalNot> CreateLogicalNot(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalNotBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MatrixDiag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_K = 4,
    VT_NUMROWS = 6,
    VT_NUMCOLS = 8,
    VT_PADDINGVALUE = 10
  };
  int32_t k() const {
    return GetField<int32_t>(VT_K, 0);
  }
  int32_t numRows() const {
    return GetField<int32_t>(VT_NUMROWS, 0);
  }
  int32_t numCols() const {
    return GetField<int32_t>(VT_NUMCOLS, 0);
  }
  float paddingValue() const {
    return GetField<float>(VT_PADDINGVALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_K) &&
           VerifyField<int32_t>(verifier, VT_NUMROWS) &&
           VerifyField<int32_t>(verifier, VT_NUMCOLS) &&
           VerifyField<float>(verifier, VT_PADDINGVALUE) &&
           verifier.EndTable();
  }
};

struct MatrixDiagBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_k(int32_t k) {
    fbb_.AddElement<int32_t>(MatrixDiag::VT_K, k, 0);
  }
  void add_numRows(int32_t numRows) {
    fbb_.AddElement<int32_t>(MatrixDiag::VT_NUMROWS, numRows, 0);
  }
  void add_numCols(int32_t numCols) {
    fbb_.AddElement<int32_t>(MatrixDiag::VT_NUMCOLS, numCols, 0);
  }
  void add_paddingValue(float paddingValue) {
    fbb_.AddElement<float>(MatrixDiag::VT_PADDINGVALUE, paddingValue, 0.0f);
  }
  explicit MatrixDiagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixDiagBuilder &operator=(const MatrixDiagBuilder &);
  flatbuffers::Offset<MatrixDiag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixDiag>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixDiag> CreateMatrixDiag(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t k = 0,
    int32_t numRows = 0,
    int32_t numCols = 0,
    float paddingValue = 0.0f) {
  MatrixDiagBuilder builder_(_fbb);
  builder_.add_paddingValue(paddingValue);
  builder_.add_numCols(numCols);
  builder_.add_numRows(numRows);
  builder_.add_k(k);
  return builder_.Finish();
}

struct Select FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SelectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectBuilder &operator=(const SelectBuilder &);
  flatbuffers::Offset<Select> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Select>(end);
    return o;
  }
};

inline flatbuffers::Offset<Select> CreateSelect(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TfReduce FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  ReduceType type() const {
    return static_cast<ReduceType>(GetField<int8_t>(VT_TYPE, 7));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct TfReduceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ReduceType type) {
    fbb_.AddElement<int8_t>(TfReduce::VT_TYPE, static_cast<int8_t>(type), 7);
  }
  explicit TfReduceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TfReduceBuilder &operator=(const TfReduceBuilder &);
  flatbuffers::Offset<TfReduce> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TfReduce>(end);
    return o;
  }
};

inline flatbuffers::Offset<TfReduce> CreateTfReduce(
    flatbuffers::FlatBufferBuilder &_fbb,
    ReduceType type = ReduceType_UNKNOW) {
  TfReduceBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Reverse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct ReverseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(Reverse::VT_AXIS, axis);
  }
  explicit ReverseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseBuilder &operator=(const ReverseBuilder &);
  flatbuffers::Offset<Reverse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reverse>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reverse> CreateReverse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  ReverseBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reverse> CreateReverseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateReverse(
      _fbb,
      axis__);
}

struct Round FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RoundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RoundBuilder &operator=(const RoundBuilder &);
  flatbuffers::Offset<Round> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Round>(end);
    return o;
  }
};

inline flatbuffers::Offset<Round> CreateRound(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RoundBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Scatter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ScatterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScatterBuilder &operator=(const ScatterBuilder &);
  flatbuffers::Offset<Scatter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scatter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scatter> CreateScatter(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ScatterND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ScatterNDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScatterNDBuilder &operator=(const ScatterNDBuilder &);
  flatbuffers::Offset<ScatterND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterND>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterND> CreateScatterND(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterNDBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Unique FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTTYPE = 4
  };
  int32_t outType() const {
    return GetField<int32_t>(VT_OUTTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTTYPE) &&
           verifier.EndTable();
  }
};

struct UniqueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outType(int32_t outType) {
    fbb_.AddElement<int32_t>(Unique::VT_OUTTYPE, outType, 0);
  }
  explicit UniqueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniqueBuilder &operator=(const UniqueBuilder &);
  flatbuffers::Offset<Unique> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unique>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unique> CreateUnique(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outType = 0) {
  UniqueBuilder builder_(_fbb);
  builder_.add_outType(outType);
  return builder_.Finish();
}

struct Unstack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM = 4,
    VT_AXIS = 6
  };
  int32_t num() const {
    return GetField<int32_t>(VT_NUM, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct UnstackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(int32_t num) {
    fbb_.AddElement<int32_t>(Unstack::VT_NUM, num, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Unstack::VT_AXIS, axis, 0);
  }
  explicit UnstackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnstackBuilder &operator=(const UnstackBuilder &);
  flatbuffers::Offset<Unstack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unstack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unstack> CreateUnstack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num = 0,
    int32_t axis = 0) {
  UnstackBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num(num);
  return builder_.Finish();
}

struct OnnxInt8Quantize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OnnxInt8QuantizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OnnxInt8QuantizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OnnxInt8QuantizeBuilder &operator=(const OnnxInt8QuantizeBuilder &);
  flatbuffers::Offset<OnnxInt8Quantize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnnxInt8Quantize>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnnxInt8Quantize> CreateOnnxInt8Quantize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OnnxInt8QuantizeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OnnxInt8Dequantize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OnnxInt8DequantizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OnnxInt8DequantizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OnnxInt8DequantizeBuilder &operator=(const OnnxInt8DequantizeBuilder &);
  flatbuffers::Offset<OnnxInt8Dequantize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnnxInt8Dequantize>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnnxInt8Dequantize> CreateOnnxInt8Dequantize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OnnxInt8DequantizeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FakeQuantWithMinMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FakeQuantWithMinMaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FakeQuantWithMinMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantWithMinMaxBuilder &operator=(const FakeQuantWithMinMaxBuilder &);
  flatbuffers::Offset<FakeQuantWithMinMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMax> CreateFakeQuantWithMinMax(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FakeQuantWithMinMaxBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FakeQuantWithMinMaxPerChannel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FakeQuantWithMinMaxPerChannelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FakeQuantWithMinMaxPerChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantWithMinMaxPerChannelBuilder &operator=(const FakeQuantWithMinMaxPerChannelBuilder &);
  flatbuffers::Offset<FakeQuantWithMinMaxPerChannel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMaxPerChannel>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMaxPerChannel> CreateFakeQuantWithMinMaxPerChannel(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FakeQuantWithMinMaxPerChannelBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchNormFold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BatchNormFoldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchNormFoldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchNormFoldBuilder &operator=(const BatchNormFoldBuilder &);
  flatbuffers::Offset<BatchNormFold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNormFold>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNormFold> CreateBatchNormFold(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BatchNormFoldBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MulFold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MulFoldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MulFoldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulFoldBuilder &operator=(const MulFoldBuilder &);
  flatbuffers::Offset<MulFold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulFold>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulFold> CreateMulFold(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MulFoldBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AddFold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AddFoldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddFoldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddFoldBuilder &operator=(const AddFoldBuilder &);
  flatbuffers::Offset<AddFold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddFold>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddFold> CreateAddFold(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddFoldBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SquaredDifference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SquaredDifferenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquaredDifferenceBuilder &operator=(const SquaredDifferenceBuilder &);
  flatbuffers::Offset<SquaredDifference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquaredDifference>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquaredDifferenceBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TupleGetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TupleGetItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TupleGetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TupleGetItemBuilder &operator=(const TupleGetItemBuilder &);
  flatbuffers::Offset<TupleGetItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TupleGetItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<TupleGetItem> CreateTupleGetItem(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TupleGetItemBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OptMomentum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OptMomentumBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OptMomentumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OptMomentumBuilder &operator=(const OptMomentumBuilder &);
  flatbuffers::Offset<OptMomentum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OptMomentum>(end);
    return o;
  }
};

inline flatbuffers::Offset<OptMomentum> CreateOptMomentum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OptMomentumBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Where FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONDITION = 4
  };
  const flatbuffers::Vector<uint8_t> *condition() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONDITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONDITION) &&
           verifier.VerifyVector(condition()) &&
           verifier.EndTable();
  }
};

struct WhereBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_condition(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> condition) {
    fbb_.AddOffset(Where::VT_CONDITION, condition);
  }
  explicit WhereBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhereBuilder &operator=(const WhereBuilder &);
  flatbuffers::Offset<Where> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Where>(end);
    return o;
  }
};

inline flatbuffers::Offset<Where> CreateWhere(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> condition = 0) {
  WhereBuilder builder_(_fbb);
  builder_.add_condition(condition);
  return builder_.Finish();
}

inline flatbuffers::Offset<Where> CreateWhereDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *condition = nullptr) {
  auto condition__ = condition ? _fbb.CreateVector<uint8_t>(*condition) : 0;
  return mindspore::schema::CreateWhere(
      _fbb,
      condition__);
}

struct OneHot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct OneHotBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(OneHot::VT_AXIS, axis, 0);
  }
  explicit OneHotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneHotBuilder &operator=(const OneHotBuilder &);
  flatbuffers::Offset<OneHot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHot>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHot> CreateOneHot(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  OneHotBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct Lstm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIDIRECTION = 4
  };
  bool bidirection() const {
    return GetField<uint8_t>(VT_BIDIRECTION, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BIDIRECTION) &&
           verifier.EndTable();
  }
};

struct LstmBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bidirection(bool bidirection) {
    fbb_.AddElement<uint8_t>(Lstm::VT_BIDIRECTION, static_cast<uint8_t>(bidirection), 0);
  }
  explicit LstmBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LstmBuilder &operator=(const LstmBuilder &);
  flatbuffers::Offset<Lstm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lstm>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lstm> CreateLstm(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool bidirection = false) {
  LstmBuilder builder_(_fbb);
  builder_.add_bidirection(bidirection);
  return builder_.Finish();
}

struct PriorBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_SIZES = 4,
    VT_MAX_SIZES = 6,
    VT_ASPECT_RATIOS = 8,
    VT_VARIANCES = 10,
    VT_IMAGE_SIZE_W = 12,
    VT_IMAGE_SIZE_H = 14,
    VT_STEP_W = 16,
    VT_STEP_H = 18,
    VT_CLIP = 20,
    VT_FLIP = 22,
    VT_OFFSET = 24
  };
  const flatbuffers::Vector<int32_t> *min_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MIN_SIZES);
  }
  const flatbuffers::Vector<int32_t> *max_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MAX_SIZES);
  }
  const flatbuffers::Vector<float> *aspect_ratios() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ASPECT_RATIOS);
  }
  const flatbuffers::Vector<float> *variances() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARIANCES);
  }
  int32_t image_size_w() const {
    return GetField<int32_t>(VT_IMAGE_SIZE_W, 0);
  }
  int32_t image_size_h() const {
    return GetField<int32_t>(VT_IMAGE_SIZE_H, 0);
  }
  float step_w() const {
    return GetField<float>(VT_STEP_W, 0.0f);
  }
  float step_h() const {
    return GetField<float>(VT_STEP_H, 0.0f);
  }
  bool clip() const {
    return GetField<uint8_t>(VT_CLIP, 1) != 0;
  }
  bool flip() const {
    return GetField<uint8_t>(VT_FLIP, 1) != 0;
  }
  float offset() const {
    return GetField<float>(VT_OFFSET, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN_SIZES) &&
           verifier.VerifyVector(min_sizes()) &&
           VerifyOffset(verifier, VT_MAX_SIZES) &&
           verifier.VerifyVector(max_sizes()) &&
           VerifyOffset(verifier, VT_ASPECT_RATIOS) &&
           verifier.VerifyVector(aspect_ratios()) &&
           VerifyOffset(verifier, VT_VARIANCES) &&
           verifier.VerifyVector(variances()) &&
           VerifyField<int32_t>(verifier, VT_IMAGE_SIZE_W) &&
           VerifyField<int32_t>(verifier, VT_IMAGE_SIZE_H) &&
           VerifyField<float>(verifier, VT_STEP_W) &&
           VerifyField<float>(verifier, VT_STEP_H) &&
           VerifyField<uint8_t>(verifier, VT_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_FLIP) &&
           VerifyField<float>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct PriorBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> min_sizes) {
    fbb_.AddOffset(PriorBox::VT_MIN_SIZES, min_sizes);
  }
  void add_max_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> max_sizes) {
    fbb_.AddOffset(PriorBox::VT_MAX_SIZES, max_sizes);
  }
  void add_aspect_ratios(flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios) {
    fbb_.AddOffset(PriorBox::VT_ASPECT_RATIOS, aspect_ratios);
  }
  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
    fbb_.AddOffset(PriorBox::VT_VARIANCES, variances);
  }
  void add_image_size_w(int32_t image_size_w) {
    fbb_.AddElement<int32_t>(PriorBox::VT_IMAGE_SIZE_W, image_size_w, 0);
  }
  void add_image_size_h(int32_t image_size_h) {
    fbb_.AddElement<int32_t>(PriorBox::VT_IMAGE_SIZE_H, image_size_h, 0);
  }
  void add_step_w(float step_w) {
    fbb_.AddElement<float>(PriorBox::VT_STEP_W, step_w, 0.0f);
  }
  void add_step_h(float step_h) {
    fbb_.AddElement<float>(PriorBox::VT_STEP_H, step_h, 0.0f);
  }
  void add_clip(bool clip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_CLIP, static_cast<uint8_t>(clip), 1);
  }
  void add_flip(bool flip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_FLIP, static_cast<uint8_t>(flip), 1);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(PriorBox::VT_OFFSET, offset, 0.0f);
  }
  explicit PriorBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PriorBoxBuilder &operator=(const PriorBoxBuilder &);
  flatbuffers::Offset<PriorBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PriorBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<PriorBox> CreatePriorBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> min_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> max_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
    int32_t image_size_w = 0,
    int32_t image_size_h = 0,
    float step_w = 0.0f,
    float step_h = 0.0f,
    bool clip = true,
    bool flip = true,
    float offset = 0.0f) {
  PriorBoxBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_step_h(step_h);
  builder_.add_step_w(step_w);
  builder_.add_image_size_h(image_size_h);
  builder_.add_image_size_w(image_size_w);
  builder_.add_variances(variances);
  builder_.add_aspect_ratios(aspect_ratios);
  builder_.add_max_sizes(max_sizes);
  builder_.add_min_sizes(min_sizes);
  builder_.add_flip(flip);
  builder_.add_clip(clip);
  return builder_.Finish();
}

inline flatbuffers::Offset<PriorBox> CreatePriorBoxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *min_sizes = nullptr,
    const std::vector<int32_t> *max_sizes = nullptr,
    const std::vector<float> *aspect_ratios = nullptr,
    const std::vector<float> *variances = nullptr,
    int32_t image_size_w = 0,
    int32_t image_size_h = 0,
    float step_w = 0.0f,
    float step_h = 0.0f,
    bool clip = true,
    bool flip = true,
    float offset = 0.0f) {
  auto min_sizes__ = min_sizes ? _fbb.CreateVector<int32_t>(*min_sizes) : 0;
  auto max_sizes__ = max_sizes ? _fbb.CreateVector<int32_t>(*max_sizes) : 0;
  auto aspect_ratios__ = aspect_ratios ? _fbb.CreateVector<float>(*aspect_ratios) : 0;
  auto variances__ = variances ? _fbb.CreateVector<float>(*variances) : 0;
  return mindspore::schema::CreatePriorBox(
      _fbb,
      min_sizes__,
      max_sizes__,
      aspect_ratios__,
      variances__,
      image_size_w,
      image_size_h,
      step_w,
      step_h,
      clip,
      flip,
      offset);
}

struct SpaceToBatchND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_PADDINGS = 6
  };
  const flatbuffers::Vector<int32_t> *blockShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  const flatbuffers::Vector<int32_t> *paddings() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyVector(blockShape()) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyVector(paddings()) &&
           verifier.EndTable();
  }
};

struct SpaceToBatchNDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape) {
    fbb_.AddOffset(SpaceToBatchND::VT_BLOCKSHAPE, blockShape);
  }
  void add_paddings(flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings) {
    fbb_.AddOffset(SpaceToBatchND::VT_PADDINGS, paddings);
  }
  explicit SpaceToBatchNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToBatchNDBuilder &operator=(const SpaceToBatchNDBuilder &);
  flatbuffers::Offset<SpaceToBatchND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatchND>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings = 0) {
  SpaceToBatchNDBuilder builder_(_fbb);
  builder_.add_paddings(paddings);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchNDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *blockShape = nullptr,
    const std::vector<int32_t> *paddings = nullptr) {
  auto blockShape__ = blockShape ? _fbb.CreateVector<int32_t>(*blockShape) : 0;
  auto paddings__ = paddings ? _fbb.CreateVector<int32_t>(*paddings) : 0;
  return mindspore::schema::CreateSpaceToBatchND(
      _fbb,
      blockShape__,
      paddings__);
}

struct TopKV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_K = 4,
    VT_SORTED = 6
  };
  const flatbuffers::Vector<int32_t> *k() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_K);
  }
  bool sorted() const {
    return GetField<uint8_t>(VT_SORTED, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_K) &&
           verifier.VerifyVector(k()) &&
           VerifyField<uint8_t>(verifier, VT_SORTED) &&
           verifier.EndTable();
  }
};

struct TopKV2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_k(flatbuffers::Offset<flatbuffers::Vector<int32_t>> k) {
    fbb_.AddOffset(TopKV2::VT_K, k);
  }
  void add_sorted(bool sorted) {
    fbb_.AddElement<uint8_t>(TopKV2::VT_SORTED, static_cast<uint8_t>(sorted), 1);
  }
  explicit TopKV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopKV2Builder &operator=(const TopKV2Builder &);
  flatbuffers::Offset<TopKV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKV2>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKV2> CreateTopKV2(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> k = 0,
    bool sorted = true) {
  TopKV2Builder builder_(_fbb);
  builder_.add_k(k);
  builder_.add_sorted(sorted);
  return builder_.Finish();
}

inline flatbuffers::Offset<TopKV2> CreateTopKV2Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *k = nullptr,
    bool sorted = true) {
  auto k__ = k ? _fbb.CreateVector<int32_t>(*k) : 0;
  return mindspore::schema::CreateTopKV2(
      _fbb,
      k__,
      sorted);
}

}  // namespace schema
}  // namespace mindspore

#endif  // FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
